{"meta":{"title":"ChenYinjie'sBlog","subtitle":"share all I have","description":"","author":"Chen Yinjie","url":"https://ghostychen.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-05-09T04:44:03.000Z","updated":"2020-05-12T00:26:36.618Z","comments":false,"path":"tags/index.html","permalink":"https://ghostychen.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-09T04:44:44.000Z","updated":"2020-05-12T00:26:36.612Z","comments":false,"path":"categories/index.html","permalink":"https://ghostychen.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"图解http读书笔记1","slug":"20200520-01-1","date":"2020-05-20T14:57:20.000Z","updated":"2020-05-20T15:02:13.806Z","comments":true,"path":"2020/05/20/20200520-01-1/","link":"","permalink":"https://ghostychen.github.io/2020/05/20/20200520-01-1/","excerpt":"","text":"第一章：了解Web及网络基础HTTP（HyperText Transfer Protocol）超文本传输协议。 TCP/IP协议族协议：各类电子设备和软件系统通过有线网络设备或无线网络设备连接，必须在统一的规则（工业标准）下才可以协调工作。 传输控制协议：transmission control protocol 网络连接协议：internet protocol TCP/IP协议族按层次分为以下四层：应用层，传输层，网络层和数据链路层。 应用层：决定了向用户提供应用服务时通信的活动 FTP协议：文件传输协议 HTTP协议 DNS：域名系统 传输层：对上层应用层，提供处于网络连接中两台计算机之间的数据传输 TCP：传输控制协议 UDP：用户数据报协议 网络层：处理网络上流动的数据包，规定了传输路线 链路层：用来处理连接网络的硬件部分 IP，TCP和DNS IP位于网络层，作用是把各种数据包传送给对方，需要满足IP地址（可能多个）和MAC地址（地理位置唯一性）才能确保传送到。IP和MAC是多对一的关系 TCP位于传输层，提供可靠的字节流服务（把大块数据分割成以报文段为单位的数据包进行管理和准确可靠的传给对方） TCP协议的三次握手策略：发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若某个阶段中断，会再次以相同的顺序发送相同的数据包。 DNSDomain Name System服务是应用层协议，提供域名到IP地址之间的解析服务。 ARPAddress resolution Protocol解析地址协议，根据通信方的IP地址反查对应的MAC地址。 URI和URLURI用字符串标识某一互联网资源，而URL表示资源的地址（互联网上所处的位置）。URL是URI的子集。 第二章：简单的HTTP协议请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。 HTTP协议规定：请求从客户端发出，最后服务器端响应请求并返回。 客户端和服务器端通信 客户端发送请求报文： 请求报文由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成。 服务器发送响应报文： 响应报文基本上由协议版本，状态码（表示请求成功或失败的数字代码），用以解释状态码的原因短语，可选的响应首部字段以及实体主体构成。 HTTP是无状态stateless协议HTTP协议自身不对请求和响应之间的通信状态进行保存。所以需要通过设置cookie来验证状态，比如session。为了更快的处理大量事务，确保协议的可伸缩性。如果对服务器本身发起请求，可以用一个*来代替请求URI 1OPTIONS * HTTP&#x2F;1.1 告知服务器意图的HTTP方法 GET：获取资源 GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。 POST：传输实体主体 PUT：传输文件 HEAD：获得报文首部 HEAD与GET方法一样，只是不返回报文主体部分。 DELETE：删除文件 OPTIONS：询问支持的方法 OPTIONS方法用来查询针对请求URI指定的资源支持的方法。 TRACE：追踪路径 CONNECT：要求用隧道协议连接代理 持节连接节省通信量持节连接特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态。 管线化：不需等待，同时发送多个请求。 使用Cookie的状态管理Cookie会根据从服务器端发送的响应报文内的一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。 Cookie是保存在客户端的，Cookie的内容可以是任意文本。但实际使用中并不直接在Cookie中包含信息，只是包含一个ID，配合服务端的session，以该ID为key获取用户信息。 第三章：HTTP报文内的HTTP信息HTTP报文HTTP报文大致分为报文首部和报文主体两块。两者由空行（CR+LF）来划分，通常不需要有报文主体。 报文结构 请求报文 请求行（请求方法，请求URI，HTTP版本） 请求首部字段 通用首部字段 实体首部字段 其他 响应报文 状态行（状态码，原因短语和HTTP版本） 响应首部字段 通用首部字段 实体首部字段 其他 编码提升传输速率 压缩传输的内容编码 分割发送的分块传输编码 发送多种数据的多部分对象集合HTTP协议采纳多部分对象集合，发送的一份报文主体内可包含多类型实体。通常在图片或文本文件等上传时使用。需要在首部字段加Content-type。 获取部分内容的范围请求情景：恢复从之前下载中断处恢复下载。 指定下载的实体范围，指定范围发送的请求叫做范围请求。首部字段Range来指定资源的byte范围。如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。 内容协商返回最合适的内容内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。 内容协商技术有三种类型 服务器驱动协商 客户端驱动协商 透明协商","categories":[{"name":"http读书笔记","slug":"http读书笔记","permalink":"https://ghostychen.github.io/categories/http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"http","slug":"http","permalink":"https://ghostychen.github.io/tags/http/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://ghostychen.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"阮一峰js教程读书笔记2","slug":"20200520-02","date":"2020-05-19T17:13:46.000Z","updated":"2020-05-20T15:02:03.116Z","comments":true,"path":"2020/05/20/20200520-02/","link":"","permalink":"https://ghostychen.github.io/2020/05/20/20200520-02/","excerpt":"","text":"对象 定义：对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，可以像函数一样调用。 如果属性的值还是一个对象，就形成了链式引用。 对象中属性的操作 读取属性 一种是使用点运算符，还有一种是使用方括号运算符。 如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。同时，方括号运算符内部还可以使用表达式。数字键可以不加引号，因为会自动转成字符串 数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 属性赋值 查看所有属性 1234567var obj &#x3D; &#123; key1: 1, key2: 2&#125;;Object.keys(obj);&#x2F;&#x2F; [&#39;key1&#39;, &#39;key2&#39;] delete命令 123456var obj &#x3D; &#123; p: 1 &#125;;Object.keys(obj) &#x2F;&#x2F; [&quot;p&quot;]delete obj.p &#x2F;&#x2F; trueobj.p &#x2F;&#x2F; undefinedObject.keys(obj) &#x2F;&#x2F; [] 删除一个不存在的属性，delete不报错，而且返回true。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 delete命令只能删除对象本身的属性，无法删除继承的属性。 in 运算符 in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。 for…in循环 for...in循环用来遍历一个对象的全部属性。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 with语句123456789101112131415161718192021222324252627with (对象) &#123; 语句;&#125;&#x2F;&#x2F; 操作同一个对象的多个属性时，提供一些书写的方便&#x2F;&#x2F; 例一var obj &#x3D; &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 &#x3D; 4; p2 &#x3D; 5;&#125;&#x2F;&#x2F; 等同于obj.p1 &#x3D; 4;obj.p2 &#x3D; 5;&#x2F;&#x2F; 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;&#x2F;&#x2F; 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量，会污染全局作用域。所以不建议使用with语句，可以用一个临时变量代替with。 运算符1.加法运算符 加法运算符存在重载，会执行相加或连接，由运算时决定。 其他运算符不会发送重载，所有运算子都转化为数值，再进行相应的数学运算。 2.算数运算符 余数运算符（运算结果的正负号由第一个运算子的正负号决定） 自增自减运算符 数值运算符，负数值运算符 数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同） 指数运算符（**） 3.赋值运算符4.比较运算符相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。 特殊情况，即任何值（包括NaN本身）与NaN比较，返回的都是false。 如果运算子是对象，会转为原始类型的值，再进行比较。 12345678var x &#x3D; [2];x &gt; &#39;11&#39; &#x2F;&#x2F; true&#x2F;&#x2F; 等同于 [2].valueOf().toString() &gt; &#39;11&#39;&#x2F;&#x2F; 即 &#39;2&#39; &gt; &#39;11&#39;[2] &gt; [11] &#x2F;&#x2F; true&#x2F;&#x2F; 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()&#x2F;&#x2F; 即 &#39;2&#39; &gt; &#39;11&#39; 严格相等运算符正0等于负0。 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。 相等运算符原始类型的数据会转换成数值类型再进行比较。 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。 undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 5.布尔运算符 取反运算符：! 123456!undefined &#x2F;&#x2F; true!null &#x2F;&#x2F; true!0 &#x2F;&#x2F; true!NaN &#x2F;&#x2F; true!&quot;&quot; &#x2F;&#x2F; true&#x2F;&#x2F;其他值都为false 且运算符：&amp;&amp; 如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。 或运算符：|| 如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。 三元运算符：?: 6.位运算符位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。用于取整。 一个数与自身的取反值相加，等于-1。 使用二进制否运算取整，是所有取整方法中最快的一种。 1234~~2.9 &#x2F;&#x2F; 2~~47.11 &#x2F;&#x2F; 47~~1.9999 &#x2F;&#x2F; 1~~3 &#x2F;&#x2F; 3 “异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。这是互换两个变量的值的最快方法。 异或运算也可以用来取整。 1234567&#x2F;&#x2F; RGB to HEX&#x2F;&#x2F; (1 &lt;&lt; 24)的作用为保证结果是6位数var rgb2hex &#x3D; function(r, g, b) &#123; return &#39;#&#39; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b) .toString(16) &#x2F;&#x2F; 先转成十六进制，然后返回字符串 .substr(1); &#x2F;&#x2F; 去除字符串的最高位，返回后面六个字符串&#125; 带符号位的右移运算符（&gt;&gt;&gt;）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。 7.其他运算符 void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。 主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。 逗号运算符用于对两个表达式求值，并返回后一个表达式的值。","categories":[{"name":"Js读书笔记","slug":"Js读书笔记","permalink":"https://ghostychen.github.io/categories/Js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ghostychen.github.io/tags/Javascript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://ghostychen.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"阮一峰js教程读书笔记1","slug":"20200520-01","date":"2020-05-19T17:13:15.000Z","updated":"2020-05-19T17:17:04.507Z","comments":true,"path":"2020/05/20/20200520-01/","link":"","permalink":"https://ghostychen.github.io/2020/05/20/20200520-01/","excerpt":"","text":"JavaScript 与 ECMAScript的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。 大事记1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求，为后来大行其道的 Ajax 应用创造了条件。 2001年，Douglas Crockford 提出了 JSON 格式，用于取代 XML 格式，进行服务器和网页之间的数据交换。JavaScript 可以原生支持这种格式，不需要额外部署代码。 语法注意点 如果使用var重新声明一个已经存在的变量，是无效的 123var x = 1;var x;x // 1 变量提升 12345678console.log(a);var a = 1;//undefined等同于var a;console.log(a); // undefineda = 1; 不合法的标识符 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换 12345678910var x = 1;switch (x) &#123; case true: console.log('x 发生类型转换'); break; default: console.log('x 没有发生类型转换');&#125;// x 没有发生类型转换 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点 数据类型 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 狭义的对象（object） 数组（array） 函数（function） 1234567891011121314151617181920212223//typeof 检测值的类型typeof 123 // \"number\"typeof '123' // \"string\"typeof false // \"boolean\"function f() &#123;&#125;typeof f// \"function\"typeof undefined// \"undefined\"v// ReferenceError: v is not definedtypeof v// \"undefined\"typeof window // \"object\"typeof &#123;&#125; // \"object\"typeof [] // \"object\"typeof null // \"object\" 123456Number(null) // 05 + null // 5Number(undefined) // NaN5 + undefined // NaN null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。 undefined表示“未定义”。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 布尔值转换规则 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 数值 所有数字都是64位浮点数形式存储 11 === 1.0 // true JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 数值精度(浮点数的64个二进制位) 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 简单的法则就是，JavaScript 对15位的十进制数都可以精确处理 NaN不是独立的数据类型，数据类型依然是Number。 12345678NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F;false [NaN].indexof(NaN) &#x2F;&#x2F;-1Boolean(NaN) &#x2F;&#x2F; falseNaN + 32 &#x2F;&#x2F; NaNNaN - 32 &#x2F;&#x2F; NaNNaN * 32 &#x2F;&#x2F; NaNNaN &#x2F; 32 &#x2F;&#x2F; NaN Infinity Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567891011121314151617181920212223242526272829303132333435363738394041424344Math.pow(2,1024) &#x2F;&#x2F;Infinity0 &#x2F; 0 &#x2F;&#x2F;NaN1 &#x2F; 0 &#x2F;&#x2F;InfinityInfinity &#x3D;&#x3D;&#x3D; -Infinity &#x2F;&#x2F;false1 &#x2F; -0 &#x2F;&#x2F;-Infinity-1 &#x2F; -0 &#x2F;&#x2F;InfinityInfinity &gt; 1000 &#x2F;&#x2F;true-Infinity &lt; -1000 &#x2F;&#x2F;trueInfinity &gt; NaN &#x2F;&#x2F; false-Infinity &gt; NaN &#x2F;&#x2F; falseInfinity &lt; NaN &#x2F;&#x2F; false-Infinity &lt; NaN &#x2F;&#x2F; false&#x2F;&#x2F;Infinity的四则运算，符合无穷的数学计算规则。5 * Infinity &#x2F;&#x2F; Infinity5 - Infinity &#x2F;&#x2F; -InfinityInfinity &#x2F; 5 &#x2F;&#x2F; Infinity5 &#x2F; Infinity &#x2F;&#x2F; 00 * Infinity &#x2F;&#x2F; NaN0 &#x2F; Infinity &#x2F;&#x2F; 0Infinity &#x2F; 0 &#x2F;&#x2F; InfinityInfinity + Infinity &#x2F;&#x2F; InfinityInfinity * Infinity &#x2F;&#x2F; InfinityInfinity - Infinity &#x2F;&#x2F; NaNInfinity &#x2F; Infinity &#x2F;&#x2F; NaNInfinity与null计算时，null会转成0，等同于与0的计算。null * Infinity &#x2F;&#x2F; NaNnull &#x2F; Infinity &#x2F;&#x2F; 0Infinity &#x2F; null &#x2F;&#x2F; InfinityInfinity与undefined计算，返回的都是NaN。undefined + Infinity &#x2F;&#x2F; NaNundefined - Infinity &#x2F;&#x2F; NaNundefined * Infinity &#x2F;&#x2F; NaNundefined &#x2F; Infinity &#x2F;&#x2F; NaNInfinity &#x2F; undefined &#x2F;&#x2F; NaN 与数值相关的全局方法 parseInt()如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串。 1234567parseInt(1000000000000000000000.5) &#x2F;&#x2F; 1&#x2F;&#x2F; 等同于parseInt(&#39;1e+21&#39;) &#x2F;&#x2F; 1parseInt(0.0000008) &#x2F;&#x2F; 8&#x2F;&#x2F; 等同于parseInt(&#39;8e-7&#39;) &#x2F;&#x2F; 8 parseFloat()字符串符合科学计数法，则会进行相应的转换。 parseFloat会将空字符串转为NaN。 isNaN()isNaN只对数值有效，如果传入其他值，会被先转成数值。 对于空数组和只有一个数值成员的数组，isNaN返回false,原因是这些数组能被Number函数转成数值。 isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。","categories":[{"name":"Js读书笔记","slug":"Js读书笔记","permalink":"https://ghostychen.github.io/categories/Js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://ghostychen.github.io/tags/Javascript/"}]},{"title":"Git常用命令速查表","slug":"art2020051902","date":"2020-05-19T12:38:14.000Z","updated":"2020-05-19T12:39:37.285Z","comments":true,"path":"2020/05/19/art2020051902/","link":"","permalink":"https://ghostychen.github.io/2020/05/19/art2020051902/","excerpt":"","text":"Git常用命令速查表创建版本库12$ git clone &lt;url&gt; #克隆远程版本库$ git init #初始化本地版本库 修改和提交123456789$ git status #查看状态$ git diff #查看变更内容$ git add . #跟踪所有改动过的文件$ git add &lt;file&gt; #跟踪指定的文件$ git mv &lt;old&gt; &lt;new&gt; #文件改名$ git rm &lt;file&gt; #删除文件$ git rm --cached &lt;file&gt; #停止跟踪文件但不删除$ git commit -m &quot;commit message&quot; #提交所有更新过的文件$ git commit --amend #修改最后一次提交 查看提交历史123$ git log #查看提交历史 $ git log -p &lt;file&gt; #查看指定文件的提交历史$ git blame &lt;file&gt; #以列表方式查看指定文件的提交历史 撤销123$ git reset --head HEAD #撤销工作目录中所有未提交文件的修改内容$ git checkout HEAD &lt;file&gt; #撤销指定的未提交文件的修改内容$ git revert &lt;commit&gt; #撤销指定的提交 分支与标签1234567$ git branch #显示所有的本地分支$ git checkout &lt;branch&#x2F;tag&gt; #切换到指定分支或标签$ git branch &lt;new-branch&gt; #创建新分支$ git branch -d &lt;branch&gt; #删除本地分支$ git tag #列出所有本地标签$ git tag &lt;tagname&gt; #基于最新提交创建标签$ git tag -d &lt;tagname&gt; #删除标签 合并与衍合12$ git merge &lt;branch&gt; #合并指定分支到当前分支$ git rebase &lt;branch&gt; #衍合指定分支到当前分支 远程操作12345678$ git remote -v #查看远程版本库信息$ git remote show &lt;remote&gt; #查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库$ git fetch &lt;remote&gt; #从远程版本库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并$ git push &lt;remote&gt; :&lt;branch&#x2F;tag-name&gt; #删除远程分支或标签$ git push --tags #上传所有标签","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ghostychen.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ghostychen.github.io/tags/git/"}]},{"title":"前端跨域解决方案","slug":"art20200519","date":"2020-05-19T12:32:16.000Z","updated":"2020-05-19T12:36:36.052Z","comments":true,"path":"2020/05/19/art20200519/","link":"","permalink":"https://ghostychen.github.io/2020/05/19/art20200519/","excerpt":"","text":"前端跨域解决方案 什么是前端跨域 跨域是浏览器为了安全做出的限制策略 浏览器请求必须遵守同源策略：同域名，同端口，同协议 怎么解决前端跨域 CORS跨域CORS跨域 - 服务端设置，前端直接调用 说明：后台允许前端某个站点进行访问 网站Easy Mock JSONP跨域JSONP跨域 - 前端适配，后台配合 说明：前后台同时改造 注意：JSONP请求不是真正的请求，在XHR中没有，只是一段JS脚本 JSONP语法 12345let url &#x3D; &quot;https:&#x2F;&#x2F;www.imooc.com&#x2F;common&#x2F;adver-getadver&quot; jsonp(url,&#123;&#125;，(err,res)&#x3D;&gt;&#123; let result &#x3D; res; this.data &#x3D; result; &#125;) 代理跨域接口代理 - 通过修改nginx服务器配置来实现 说明：前端修改，后台不动","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ghostychen.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://ghostychen.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-12T00:26:36.605Z","updated":"2020-05-12T00:26:36.605Z","comments":true,"path":"2020/05/12/hello-world/","link":"","permalink":"https://ghostychen.github.io/2020/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Vue项目文件目录结构","slug":"article","date":"2020-05-11T02:37:00.000Z","updated":"2020-05-12T00:26:36.600Z","comments":true,"path":"2020/05/11/article/","link":"","permalink":"https://ghostychen.github.io/2020/05/11/article/","excerpt":"","text":"Node环境安装window/mac安装 http://nodejs.cn/download Git安装和配置 安装 官网：https://git-scm.com/downloads 环境变量配置、开发工具配置 查看设置本地环境变量 属性 –&gt; 高级 –&gt; 环境变量 配置VsCode的Git地址 存储密码 - SSH添加公钥12345678git config --listgit config --global user.name &#39;yourname&#39;git config --global user.email &#39;youremail@example.com&#39;git config --global credential.helper store&#x2F;&#x2F;配置SSH密钥ssh-keygen -t rsa -C &#39;youremail@example.com&#39; 团队使用Git命令开发项目","categories":[{"name":"Vue全家桶高仿小米商城","slug":"Vue全家桶高仿小米商城","permalink":"https://ghostychen.github.io/categories/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%AB%98%E4%BB%BF%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ghostychen.github.io/tags/Vue/"},{"name":"Git","slug":"Git","permalink":"https://ghostychen.github.io/tags/Git/"}]}],"categories":[{"name":"http读书笔记","slug":"http读书笔记","permalink":"https://ghostychen.github.io/categories/http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Js读书笔记","slug":"Js读书笔记","permalink":"https://ghostychen.github.io/categories/Js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"前端学习","slug":"前端学习","permalink":"https://ghostychen.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Vue全家桶高仿小米商城","slug":"Vue全家桶高仿小米商城","permalink":"https://ghostychen.github.io/categories/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%AB%98%E4%BB%BF%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E/"}],"tags":[{"name":"http","slug":"http","permalink":"https://ghostychen.github.io/tags/http/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://ghostychen.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://ghostychen.github.io/tags/Javascript/"},{"name":"git","slug":"git","permalink":"https://ghostychen.github.io/tags/git/"},{"name":"跨域","slug":"跨域","permalink":"https://ghostychen.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"Vue","slug":"Vue","permalink":"https://ghostychen.github.io/tags/Vue/"},{"name":"Git","slug":"Git","permalink":"https://ghostychen.github.io/tags/Git/"}]}