<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenYinjie&#39;sBlog</title>
  
  <subtitle>share all I have</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ghostychen.github.io/"/>
  <updated>2020-06-16T15:33:46.541Z</updated>
  <id>https://ghostychen.github.io/</id>
  
  <author>
    <name>Chen Yinjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS事件循环机制(event loop)</title>
    <link href="https://ghostychen.github.io/2020/06/16/2020061601/"/>
    <id>https://ghostychen.github.io/2020/06/16/2020061601/</id>
    <published>2020-06-16T15:30:42.000Z</published>
    <updated>2020-06-16T15:33:46.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS事件循环机制-event-loop"><a href="#JS事件循环机制-event-loop" class="headerlink" title="JS事件循环机制(event loop)"></a>JS事件循环机制(event loop)</h1><ul><li>Javascript是单线程的语言</li><li>Event Loop是Javascript的执行机制</li></ul><h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>js是单线程，就像学生排队上厕所，学生需要排队一个一个上厕所，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa38dcffce?imageslim" alt="cmd-markdown-logo"></p><p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p><hr><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。</p><p><strong>一道题目：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;script start&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#39;promise1&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;script end&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;script start</span><br><span class="line">&#x2F;&#x2F;script end</span><br><span class="line">&#x2F;&#x2F;promise1</span><br><span class="line">&#x2F;&#x2F;promise2</span><br><span class="line">&#x2F;&#x2F;setTimeout</span><br></pre></td></tr></table></figure><h3 id="为什么会出现这样打印顺序呢？"><a href="#为什么会出现这样打印顺序呢？" class="headerlink" title="为什么会出现这样打印顺序呢？"></a>为什么会出现这样打印顺序呢？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fb89da87c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"></p><p>解读：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。👇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发送成功!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);</span><br></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。</p><hr><h3 id="微任务-Microtasks-、宏任务-task-？"><a href="#微任务-Microtasks-、宏任务-task-？" class="headerlink" title="微任务(Microtasks)、宏任务(task)？"></a>微任务(Microtasks)、宏任务(task)？</h3><h5 id="微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event-Loop的走向和取值。那么他们之间到底有什么区别呢？"><a href="#微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event-Loop的走向和取值。那么他们之间到底有什么区别呢？" class="headerlink" title="微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？"></a>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？</h5><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/164974fa4b42e4af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"></p><blockquote><p>一个掘金的老哥（ssssyoki）的文章摘要： 那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p></blockquote><ul><li>而宏任务一般是：包括整体代码script，setTimeout，setInterval、setImmediate。</li><li>微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了。</li><li>process</li></ul><hr><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;延时3秒&#39;);</span><br><span class="line">&#125;,3000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;,3000)</span><br><span class="line">console.log(&#39;执行console&#39;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行console</span><br><span class="line">&#x2F;&#x2F; task()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">sleep(10000000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p><ul><li>task()进入Event Table并注册,计时开始。</li><li>执行sleep函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li><li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li></ul><p>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p><hr><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>)</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 先执行这里</span></span><br><span class="line"><span class="comment">// 先执行这里</span></span><br><span class="line"><span class="comment">// 执行啦</span></span><br><span class="line"><span class="comment">// ... 3s later</span></span><br><span class="line"><span class="comment">// 执行啦</span></span><br></pre></td></tr></table></figure><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，<code>对于setInterval(fn,ms)</code>来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p><h3 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h3><ul><li>Promise的定义和功能本文不再赘述，可以学习一下 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰老师的Promise</a></li><li>而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</li></ul><h5 id="不同类型的任务会进入对应的Event-Queue，比如setTimeout和setInterval会进入相同的Event-Queue。"><a href="#不同类型的任务会进入对应的Event-Queue，比如setTimeout和setInterval会进入相同的Event-Queue。" class="headerlink" title="不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。"></a>不同类型的任务会进入对应的Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的Event Queue。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout1&#39;)</span><br><span class="line">&#125;,0)</span><br><span class="line">let p &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise1&#39;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">p.then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise2&#39;)    </span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; Promise1，Promise2，setTimeout1</span><br></pre></td></tr></table></figure><p>Promise参数中的Promise1是同步执行的，其次是因为Promise是microtasks，会在同步任务执行完后会去清空microtasks queues， 最后清空完微任务再去宏任务队列取值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise1&#39;)  </span><br><span class="line">  setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;setTimeout2&#39;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout1&#39;)</span><br><span class="line">  Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;Promise2&#39;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br><span class="line">&#x2F;&#x2F;Promise1，setTimeout1，Promise2，setTimeout2</span><br></pre></td></tr></table></figure><h5 id="这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2"><a href="#这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2" class="headerlink" title="这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2"></a>这回是嵌套，大家可以看看，最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</h5><ul><li>一开始执行栈的同步任务执行完毕，会去 microtasks queues 找 清空 microtasks queues ，输出<code>Promise1</code>，同时会生成一个异步任务 setTimeout1</li><li>去宏任务队列查看此时队列是 setTimeout1 在 setTimeout2 之前，因为setTimeout1执行栈一开始的时候就开始异步执行,所以输出 <code>setTimeout1</code></li><li>在执行setTimeout1时会生成Promise2的一个 microtasks ，放入 microtasks queues 中，接着又是一个循环，去清空 microtasks queues ，输出 <code>Promise2</code></li><li>清空完 microtasks queues ，就又会去宏任务队列取一个，这回取的是 <code>setTimeout2</code></li></ul><p>如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/14/1649751a2eb3953f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>最后我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出<code>1</code>。</li><li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li><li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为<code>then1</code>。</li><li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th align="right">微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td align="right">process1</td></tr><tr><td>setTimeout2</td><td align="right">then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了<code>1</code>和<code>7</code>。</li></ul><p>我们发现了process1和then1两个微任务。</p><ul><li>执行process1,输出<code>6</code>。</li><li>执行then1，输出<code>8</code>。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出<code>1，7，6，8</code>。那么第二轮时间循环从setTimeout1宏任务开始：</p><ul><li>首先输出<code>2</code>。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。</li><li>new Promise立即执行输出<code>4</code>，then也分发到微任务Event Queue中，记为then2</li></ul><table><thead><tr><th>宏任务Event Queue</th><th align="right">微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td align="right">process3</td></tr><tr><td></td><td align="right">then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li><li>输出<code>10</code>。</li><li>输出<code>12</code>。</li><li>第三轮事件循环结束，第三轮输出<code>9，11，10，12</code>。</li><li>整段代码，共进行了三次事件循环，完整的输出为<code>1，7，6，8，2，4，3，5，9，11，10，12</code>。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</li></ul><p>参考链接：<a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">https://juejin.im/post/5b498d245188251b193d4059</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS事件循环机制-event-loop&quot;&gt;&lt;a href=&quot;#JS事件循环机制-event-loop&quot; class=&quot;headerlink&quot; title=&quot;JS事件循环机制(event loop)&quot;&gt;&lt;/a&gt;JS事件循环机制(event loop)&lt;/h1&gt;&lt;ul
      
    
    </summary>
    
    
      <category term="JS知识点总结" scheme="https://ghostychen.github.io/categories/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="https://ghostychen.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一文看懂Ajax</title>
    <link href="https://ghostychen.github.io/2020/05/30/2020053001/"/>
    <id>https://ghostychen.github.io/2020/05/30/2020053001/</id>
    <published>2020-05-30T03:58:03.000Z</published>
    <updated>2020-05-30T03:59:57.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文看懂Ajax😁"><a href="#一文看懂Ajax😁" class="headerlink" title="一文看懂Ajax😁"></a>一文看懂Ajax😁</h1><h2 id="一、什么是Ajax"><a href="#一、什么是Ajax" class="headerlink" title="一、什么是Ajax?"></a>一、什么是Ajax?</h2><ul><li><code>Ajax</code> = 异步 <code>JavaScript</code> 和<code>XML</code>。</li><li><code>Ajax</code>是一种用于创建快速动态网页的技术。</li></ul><ul><li><p>通过在后台与服务器进行少量数据交换，<code>Ajax</code>可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p></li><li><p>传统的网页（不使用 Ajax）如果需要更新内容，必需重载整个网页面。</p><p>有很多使用 <code>Ajax</code>的应用程序案例：新浪微博、Google 地图、开心网等等。<strong>（注意：<code>Ajax</code> 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的<code>Web应用</code>程序的技术。）</strong></p></li></ul><p>Ajax最大优势在于异步交互，用户在浏览页面的同时向服务器发送请求，甚至可以不用等待前一次请求完全响应就可再次发送请求。浏览器也无须频频地重新加载新页面，服务器的响应不再是整个页面内容，而只是必须更新的部分数据。<strong>Ajax催生了网页游戏的诞生。</strong></p><ul><li>同步：同步请求与响应，一个请求必须得到服务器响应后才能进行下一个请求。</li><li>异步：用户请求发送后，完全无须等待，请求在后台发送，不会阻塞用户当前活动。用户可在请求未得到响应的情况下发送多次请求。</li></ul><h2 id="二、Ajax工作原理"><a href="#二、Ajax工作原理" class="headerlink" title="二、Ajax工作原理"></a>二、Ajax工作原理</h2><p>Ajax通过在浏览器和服务器之间添加Ajax中间层，允许浏览器异步发送请求，同时允许动态加载服务器响应。用户请求不再直接向服务器提交，而是使用XMLHttpRequest异步向服务器发送，从而避免丢失当前页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = &#123;</span><br><span class="line">    ajax:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="literal">null</span>,      <span class="comment">//XMLHttpRequest对象</span></span><br><span class="line">            url = options.url,    <span class="comment">//url地址</span></span><br><span class="line">            method = options.method || <span class="string">'get'</span>, <span class="comment">//传输方式 默认get</span></span><br><span class="line">            <span class="keyword">async</span> = <span class="keyword">typeof</span>(options.async) === <span class="string">'undefined'</span>?<span class="literal">true</span>:options.async,</span><br><span class="line">            <span class="comment">// console.log(method);</span></span><br><span class="line">            data = options.data || <span class="literal">null</span>,</span><br><span class="line">            params = <span class="string">''</span>,        <span class="comment">//参数</span></span><br><span class="line">            callback = options.success, <span class="comment">//ajax请求成功的回调函数</span></span><br><span class="line">            error = options.error;      <span class="comment">//ajax请求失败的回调函数</span></span><br><span class="line">        <span class="comment">//将data的对象字面量的形式转换为字符串形式</span></span><br><span class="line">        <span class="keyword">if</span>(data)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> data)&#123;</span><br><span class="line">                <span class="comment">// console.log(i);</span></span><br><span class="line">                params += i + <span class="string">'='</span> + data[i] + <span class="string">'&amp;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            params = params.replace(<span class="regexp">/&amp;$/</span>,<span class="string">''</span>);     </span><br><span class="line">            <span class="comment">// console.log(params); </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据method的值改变url</span></span><br><span class="line">        <span class="keyword">if</span>(method === <span class="string">'get'</span>)&#123;</span><br><span class="line">            url +=<span class="string">'?'</span> + params;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">// console.log(url);</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">'undefined'</span>)&#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> ActiveXObject != <span class="string">'undefined'</span>)&#123;</span><br><span class="line">            <span class="comment">//将所有可能出现的ActiveXObject版本放在一个数组中</span></span><br><span class="line">            <span class="keyword">var</span> xhrArr = [</span><br><span class="line">                <span class="string">'Microsoft.XMLHTTP'</span>,</span><br><span class="line">                <span class="string">'MSXML2.XMLHTTP.6.0'</span>,</span><br><span class="line">                <span class="string">'MSXML2.XMLHTTP.5.0'</span>,</span><br><span class="line">                <span class="string">'MSXML2.XMLHTTP.4.0'</span>,</span><br><span class="line">                <span class="string">'MSXML2.XMLHTTP.3.0'</span>,</span><br><span class="line">                <span class="string">'MSXML2.XMLHTTP.2.0'</span>,</span><br><span class="line">            ];</span><br><span class="line">            <span class="comment">//遍历创建XMLHttpRequest对象</span></span><br><span class="line">            <span class="keyword">var</span> len = xhrArr.length;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">                    xhr = <span class="keyword">new</span> ActiveXObject(xhrArr[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No XHR object available.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;<span class="comment">//readyState=4：响应的内容解析完毕，可以在客户端使用了--完成</span></span><br><span class="line">                <span class="keyword">if</span>(( xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">                    callback &amp;&amp; callback(<span class="built_in">JSON</span>.parse(xhr.responseText))<span class="comment">//xhr.status:获取当前服务器的响应状态  200=&gt;成功</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    error &amp;&amp; error();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建发送请求 </span></span><br><span class="line">        xhr.open(method,url,<span class="keyword">async</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        xhr.send(params);</span><br><span class="line">    &#125;,</span><br><span class="line">    jsonp:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//跨域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest对象的三个常用属性"><a href="#XMLHttpRequest对象的三个常用属性" class="headerlink" title="XMLHttpRequest对象的三个常用属性"></a>XMLHttpRequest对象的三个常用属性</h3><ol><li><h4 id="onreadystatechange属性"><a href="#onreadystatechange属性" class="headerlink" title="onreadystatechange属性"></a>onreadystatechange属性</h4><p>onreadystatechange 属性存有处理服务器响应的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F;我们需要在这写一些代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h4 id="readyState属性"><a href="#readyState属性" class="headerlink" title="readyState属性"></a>readyState属性</h4><p>readyState 属性存有服务器响应的状态信息。每当 readyState 改变时，onreadystatechange 函数就会被执行。</p><table><thead><tr><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">请求未初始化（在调用 open() 之前）</td></tr><tr><td align="left">1</td><td align="left">请求已提出（调用 send() 之前）</td></tr><tr><td align="left">2</td><td align="left">请求已发送（这里通常可以从响应得到内容头部）</td></tr><tr><td align="left">3</td><td align="left">请求处理中（响应中通常有部分数据可用，但是服务器还没有完成响应）</td></tr><tr><td align="left">4</td><td align="left">请求已完成（可以访问服务器响应并使用它）</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">    if (xmlHttp.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">        &#x2F;&#x2F;从服务器的response获得数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><h4 id="responseText属性"><a href="#responseText属性" class="headerlink" title="responseText属性"></a>responseText属性</h4><p>可以通过 responseText 属性来取回由服务器返回的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">    if (xmlHttp.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">        document.myForm.time.value &#x3D; xmlHttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="XMLHttpRequest对象的方法"><a href="#XMLHttpRequest对象的方法" class="headerlink" title="XMLHttpRequest对象的方法"></a>XMLHttpRequest对象的方法</h3><ol><li><h4 id="open-方法"><a href="#open-方法" class="headerlink" title="open()方法"></a>open()方法</h4><p>open() 有三个参数。第一个参数定义发送请求所使用的方法，第二个参数规定服务器端脚本的URL，第三个参数规定应当对请求进行异步地处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.open(&quot;GET&quot;,&quot;test.php&quot;,true);</span><br></pre></td></tr></table></figure></li><li><h4 id="send-方法"><a href="#send-方法" class="headerlink" title="send()方法"></a>send()方法</h4><p>send() 方法将请求送往服务器。如果我们假设 HTML 文件和 PHP 文件位于相同的目录，那么代码是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.send(null);</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、Ajax的使用及实现步骤"><a href="#三、Ajax的使用及实现步骤" class="headerlink" title="三、Ajax的使用及实现步骤"></a>三、Ajax的使用及实现步骤</h2><ol><li>创建<code>XMLHttpRequest</code>对象,也就是创建一个异步调用对象.</li><li>创建一个新的<code>HTTP</code>请求,并指定该<code>HTTP</code>请求的方法、<code>URL</code>及验证信息.</li><li>设置响应<code>HTTP</code>请求状态变化的函数.</li><li>发送<code>HTTP</code>请求.</li><li>获取异步调用返回的数据.</li><li>使用JavaScript和DOM实现局部刷新.</li></ol><hr><ol><li><p>创建Ajax核心对象XMLHttpRequest</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;  <span class="comment">//针对除IE6以外的浏览器</span></span><br><span class="line">    xmlHttp=<span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//实例化一个XMLHttpRequest</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);   <span class="comment">//针对IE5,IE6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向服务器发送请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(method,url,async);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></li><li><p>完整示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xmlHttp &#x3D; new XMLHttpRequest();</span><br><span class="line">   xmlHttp.open(&#39;get&#39;,&#39;demo_get.html&#39;,&#39;true&#39;);&#x2F;&#x2F;调用open()方法并采用异步方式</span><br><span class="line">   xmlHttp.send(); &#x2F;&#x2F;使用open()方法将请求发送出去</span><br><span class="line">   xmlHttp.onreadystatechange()&#x3D;&gt;&#123;</span><br><span class="line">        if(xmlHttp.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xmlHttp.status &#x3D;&#x3D;&#x3D; 200)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="四、详解区分请求类型-GET-或-POST"><a href="#四、详解区分请求类型-GET-或-POST" class="headerlink" title="四、详解区分请求类型:GET 或 POST"></a>四、详解区分请求类型:GET 或 POST</h2><h3 id="GET-还是-POST？"><a href="#GET-还是-POST？" class="headerlink" title="GET 还是 POST？"></a>GET 还是 POST？</h3><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>然而，在以下情况中，请使用 POST 请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.open(&quot;GET&quot;,&quot;demo_get.html&quot;,true); </span><br><span class="line">xmlHttp.send();</span><br><span class="line">&#x2F;&#x2F;上面的例子中，您可能得到的是缓存的结果。</span><br><span class="line">&#x2F;&#x2F;避免这种情况，请向 URL 添加一个唯一的 ID</span><br><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;demo_get.html?t&#x3D;&quot; + Math.random(),true); </span><br><span class="line">xmlhttp.send();</span><br><span class="line">&#x2F;&#x2F;如果您希望通过 GET 方法发送信息，请向 URL 添加信息：</span><br><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;demo_get2.html?fname&#x3D;Henry&amp;lname&#x3D;Ford&quot;,true); </span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p><strong>提示：GET请求具有以下的几个特点：</strong></p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据</li></ul><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;demo_post.html&quot;,true); </span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>如果需要像 <code>HTML 表单</code>那样 POST 数据，请使用<code>setRequestHeader()</code> 来添加 HTTP 头。然后在<code>send()</code>方法中规定您希望发送的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.html&quot;,true); </span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application&#x2F;x-www-form-urlencoded&quot;); </span><br><span class="line">xmlhttp.send(&quot;fname&#x3D;Henry&amp;lname&#x3D;Ford&quot;);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">setRequestHeader(<em>header,value</em>)</td><td align="center">向请求添加 HTTP头    ▪ header: 规定头的名称;     ▪ value: 规定头的值</td></tr></tbody></table><p><strong>POST请求特点：</strong></p><ul><li>POST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 请求不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><h5 id="为什么使用-Async-true-？"><a href="#为什么使用-Async-true-？" class="headerlink" title="为什么使用 Async=true ？"></a>为什么使用 Async=true ？</h5><p>我们的实例在 open() 的第三个参数中使用了 “true”。该参数规定请求是否异步处理。True 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应。<br>  onreadystatechange事件使代码复杂化了。但是这是在没有得到服务器响应的情况下，防止代码停止的最安全的方法。<br>  通过把该参数设置为 “false”，可以省去额外的 onreadystatechange 代码。如果在请求失败时是否执行其余的代码无关紧要，那么可以使用这个参数。</p><h2 id="五、Ajax中的一些处理"><a href="#五、Ajax中的一些处理" class="headerlink" title="五、Ajax中的一些处理"></a>五、Ajax中的一些处理</h2><h3 id="1-服务器响应处理"><a href="#1-服务器响应处理" class="headerlink" title="1. 服务器响应处理"></a>1. 服务器响应处理</h3><p>  responseText 获得字符串形式的响应数据。<br>  responseXML 获得XML 形式的响应数据。</p><h3 id="2-同步处理"><a href="#2-同步处理" class="headerlink" title="2. 同步处理"></a>2. 同步处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.open(&quot;GET&quot;,&quot;demo_get.html&quot;,false);</span><br><span class="line">xmlHttp.send();</span><br><span class="line">document.getElementById(&quot;target&quot;).innerHTML&#x3D;xmlHttp.responseText;</span><br><span class="line">&#x2F;&#x2F;直接在send()后面处理返回的数据</span><br></pre></td></tr></table></figure><h3 id="3-异步处理"><a href="#3-异步处理" class="headerlink" title="3. 异步处理"></a>3. 异步处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange&#x3D;function()&#123;&#x2F;&#x2F;接收到服务端响应时触发</span><br><span class="line">if(xmlHttp.readyState&#x3D;&#x3D;4&amp;&amp;xmlHttp.status&#x3D;&#x3D;200)&#123;</span><br><span class="line">document.getElementById(&quot;target&quot;).innerHTML&#x3D;xmlHttp.responseText;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>xmlhttp.status</code>的常见状态码</strong></p><ul><li>200: “OK”</li><li>304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</li><li>403 （禁止） 服务器拒绝请求。</li><li>404 （未找到） 服务器找不到请求的网页。</li><li>408 （请求超时） 服务器等候请求时发生超时。</li><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一文看懂Ajax😁&quot;&gt;&lt;a href=&quot;#一文看懂Ajax😁&quot; class=&quot;headerlink&quot; title=&quot;一文看懂Ajax😁&quot;&gt;&lt;/a&gt;一文看懂Ajax😁&lt;/h1&gt;&lt;h2 id=&quot;一、什么是Ajax&quot;&gt;&lt;a href=&quot;#一、什么是Ajax&quot; c
      
    
    </summary>
    
    
      <category term="前端学习" scheme="https://ghostychen.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Ajax" scheme="https://ghostychen.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>SQL笔记</title>
    <link href="https://ghostychen.github.io/2020/05/28/20200528-01/"/>
    <id>https://ghostychen.github.io/2020/05/28/20200528-01/</id>
    <published>2020-05-27T17:27:00.000Z</published>
    <updated>2020-05-27T17:28:45.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-笔记"><a href="#SQL-笔记" class="headerlink" title="SQL 笔记"></a>SQL 笔记</h1><h2 id="SQL-简介"><a href="#SQL-简介" class="headerlink" title="SQL 简介"></a>SQL 简介</h2><p>SQL = Structured Query Language</p><p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p><ul><li><p>DDL：Data Definition Language</p><p>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p></li><li><p>DML：Data Manipulation Language</p><p>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p></li><li><p>DQL：Data Query Language</p><p>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p></li></ul><h2 id="数据库类别"><a href="#数据库类别" class="headerlink" title="数据库类别"></a>数据库类别</h2><ul><li>关系型数据库(SQL)</li><li>非关系型数据库(NoSQL) - MongoDB, Cassandra, Dynamo</li></ul><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键是关系表中记录的唯一标识。选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;student&gt;</span><br><span class="line">ADD CONSTRAINT &lt;pk_id&gt;</span><br><span class="line">PRIMARY KEY (&lt;id&gt;);</span><br></pre></td></tr></table></figure><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>外键是用来关联 2 个表结构的，表直接的约束分为以下 3 种：</p><ol><li>一对一</li><li>一对多 - 外键建立在‘多’的表中(即从表)</li><li>多对多 - 需要建立中间表</li></ol><ul><li><p>创建外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;student&gt;</span><br><span class="line">ADD CONSTRAINT &lt;fk_class_id&gt;</span><br><span class="line">FOREIGN KEY (&lt;class_id&gt;)</span><br><span class="line">REFERENCES classes (&lt;id&gt;);</span><br></pre></td></tr></table></figure></li><li><p>删除外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;students&gt;</span><br><span class="line">DROP FOREIGN KEY &lt;fk_class_id&gt;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;students&gt;</span><br><span class="line">ADD INDEX &lt;idx_name_score&gt; (&lt;name&gt;, &lt;score&gt;);</span><br></pre></td></tr></table></figure><ul><li><p>唯一索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;students&gt;</span><br><span class="line">ADD UNIQUE INDEX &lt;uni_name&gt; (&lt;name&gt;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>根据业务要求，像身份号、手机号、邮箱地址等，它们具有业务含义不易作为主键，但是又具有唯一性：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;students&gt;</span><br><span class="line">ADD CONSTRAINT &lt;uni_name&gt;</span><br><span class="line">UNIQUE (&lt;name&gt;);</span><br></pre></td></tr></table></figure><h3 id="SQL-查询"><a href="#SQL-查询" class="headerlink" title="SQL 查询"></a>SQL 查询</h3><p>不带 <code>FROM</code> 子句的 <code>SELECT</code> 语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条 <code>SELECT 1;</code> 来测试数据库连接。</p><ol><li><p>基本查询 - <code>SELECT * FROM</code></p></li><li><p>条件查询 - <code>SELECT * FROM  WHERE id = 1</code></p></li><li><p>投影查询 - <code>SELECT id, name FROM</code></p></li><li><p>排序 - <code>SELECT * FROM  ORDER BY id DESC</code> NOTE: <code>OREDER BY</code> 要在 <code>WHERE</code> 条件后</p></li><li><p>分页查询 - <code>SELECT * FROM  LIMIT &lt;10&gt; OFFSET &lt;0&gt;</code> <code>pageSize</code> - <code>LIMIT</code> <code>pageIndex</code> - <code>OFFSET</code>=<code>pageSize * (pageIndex - 1)</code>, <code>pageIndex</code> 从 <code>1</code> 开始，而 <code>OFFSET</code> 从 <code>0</code> 开始。</p></li><li><p>聚合查询 聚合函数：<code>COUNT(), SUM(), AVG(), MAX(), MIN()</code> 通过 <code>GROUP BY</code> 进行分组 <code>SELECT , , COUNT(*) num FROM  GROUP BY , ;</code></p></li><li><p>多表查询 - <code>SELECT * FROM , ;</code> 获得的集合为 A 表行数 * B 表行数</p></li><li><p>连接查询</p><ul><li>内连接(INNER JOIN)</li><li>外连接(OUTER JOIN)<ul><li>左连接(LEFT OUTER JOIN)</li><li>右连接(RIGHT OUTER JOIN)</li><li>全连接(FULL OUTER JOIN)</li></ul></li></ul><table><thead><tr><th>INNER JOIN</th><th>LEFT OUTER JOIN</th><th>RIGHT OUTER JOIN</th><th>FULL OUTER JOIN</th></tr></thead><tbody><tr><td>两张表都存在的记录</td><td>左表存在的记录</td><td>右表存在的记录</td><td>左右表都存在的记录</td></tr><tr><td><a href="https://github.com/v-tawe/StudyNotes/blob/master/SQL/INNER_JOIN.png" target="_blank" rel="noopener"><img src="https://github.com/v-tawe/StudyNotes/raw/master/SQL/INNER_JOIN.png" alt="img"></a></td><td><a href="https://github.com/v-tawe/StudyNotes/blob/master/SQL/LEFT_OUTER_JOIN.png" target="_blank" rel="noopener"><img src="https://github.com/v-tawe/StudyNotes/raw/master/SQL/LEFT_OUTER_JOIN.png" alt="img"></a></td><td><a href="https://github.com/v-tawe/StudyNotes/blob/master/SQL/RIGHT_OUTER_JOIN.png" target="_blank" rel="noopener"><img src="https://github.com/v-tawe/StudyNotes/raw/master/SQL/RIGHT_OUTER_JOIN.png" alt="img"></a></td><td><a href="https://github.com/v-tawe/StudyNotes/blob/master/SQL/FULL_OUTER_JOIN.png" target="_blank" rel="noopener"><img src="https://github.com/v-tawe/StudyNotes/raw/master/SQL/FULL_OUTER_JOIN.png" alt="img"></a></td></tr></tbody></table></li></ol><h3 id="SQL-修改"><a href="#SQL-修改" class="headerlink" title="SQL 修改"></a>SQL 修改</h3><p>关系数据库的基本操作就是增删改查，即 <code>CRUD：Create、Retrieve、Update、Delete</code>。</p><p>对于增、删、改，对应的SQL语句分别是：</p><ul><li><code>INSERT</code>：插入新记录 - <code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></li><li><code>UPDATE</code>：更新已有记录 - <code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</code></li><li><code>DELETE</code>：删除已有记录 - <code>DELETE FROM &lt;表名&gt; WHERE ...;</code></li></ul><h2 id="常用-SQL-语句"><a href="#常用-SQL-语句" class="headerlink" title="常用 SQL 语句"></a>常用 SQL 语句</h2><h3 id="数据库-表操作-SQL-语句"><a href="#数据库-表操作-SQL-语句" class="headerlink" title="数据库 + 表操作 SQL 语句"></a>数据库 + 表操作 SQL 语句</h3><table><thead><tr><th>SQL 语句</th><th>含义</th></tr></thead><tbody><tr><td>SHOW DATABASES</td><td>列出所有数据库</td></tr><tr><td>CREATE DATABASE <database_name></td><td>创建数据库</td></tr><tr><td>DROP DATABASE <database_name></td><td>删除数据库</td></tr><tr><td>USE <database_name></td><td>切换当前数据库</td></tr><tr><td>SHOW TABLES</td><td>列出所有表</td></tr><tr><td>DESC <table_name></td><td>查看表结构</td></tr><tr><td>SHOW CREATE TABLE <table_name></td><td>查看创建表的 SQL 语句</td></tr><tr><td>DROP TABLE <table_name></td><td>删除表</td></tr><tr><td>ALTER TABLE <table_name> ADD COLUMN <column_name> VARCHAR(10) NOT NULL</td><td>新增列</td></tr><tr><td>ALTER TABLE <table_name> CHANGE COLUMN <column_name> VARCHAR(20) NOT NULL</td><td>修改列属性</td></tr><tr><td>ALTER TABLE <table_name> DROP COLUMN <column_name></td><td>删除列</td></tr><tr><td>EXIT</td><td>退出 MYSQL 连接</td></tr></tbody></table><h3 id="实用-SQL-语句"><a href="#实用-SQL-语句" class="headerlink" title="实用 SQL 语句"></a>实用 SQL 语句</h3><ul><li>插入或替换 <code>REPLACE INTO  (, , &lt;...&gt;) VALUES(&lt;1&gt;, &lt;1&gt;, &lt;...&gt;)</code> 若 <code>id=1</code> 记录不存在，插入新纪录； 若 <code>id=1</code> 记录存在，当前 <code>id=1</code> 记录被删除，然后再插入新纪录。</li><li>插入或更新 <code>INSERT INTO  (, , , &lt;...&gt;) VALUES(&lt;1&gt;, &lt;1&gt;, &lt;&#39;xiao_min&#39;&gt;, &lt;...&gt;) ON DUPLICATE KEY UPDATE =&lt;&#39;xiao_min&#39;&gt;, &lt;...&gt;;</code> 若 <code>id=1</code> 记录不存在，插入新纪录； 若 <code>id=1</code> 记录存在，当前 <code>id=1</code> 记录被更新，更新字段有 <code>UPDATE</code> 指定。</li><li>插入或忽略 <code>INSERT IGNORE INTO  (, , &lt;...&gt;) VALUES(&lt;1&gt;, &lt;1&gt;, &lt;...&gt;);</code> 若 <code>id=1</code>记录不存在，<code>INSERT</code> 语句将插入新记录，否则，不执行任何操作。</li><li>快照 <code>CREATE TABLE  SELECT * FROM  WHERE =&lt;1&gt;;</code> 通过查询集合创建新表</li></ul><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些 SQL 一样，不会对数据库数据有任何改动。</p><ul><li><code>BEGIN</code> 开启一个事务</li><li><code>COMMIT</code> 提交一个事务</li><li><code>ROLLBACK</code> 回滚事务</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li><strong>脏读 DIRTY READ</strong>： 查询同一记录，2 次结果<strong>不一样</strong>，读到还未 commit 的数据结果；</li><li><strong>不可重复读 NON REPEATABLE READ</strong>： 查询同一记录，2 次结果<strong>不一样</strong>，读到的结果在另一事务 commit/rollback 之间；</li><li><strong>幻读 PHANTOM READ</strong>：查询同一记录，2 次结果是<strong>一样</strong>，但是会出现 事务 A 新增的列，事务 B 读不到(<code>SELECT</code>)，但是却可以更新(<code>UPDATE</code>)，更新后才可以读到。</li></ul><table><thead><tr><th>ISOLATION LEVEL</th><th>DIRTY READ</th><th>NON REPEATABLE READ</th><th>PHANTOM READ</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>READ COMMITTED</td><td>-</td><td>YES</td><td>YES</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>YES</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p><strong>Serializable</strong> 虽然隔离级别最高，但是效率会大大下降。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL-笔记&quot;&gt;&lt;a href=&quot;#SQL-笔记&quot; class=&quot;headerlink&quot; title=&quot;SQL 笔记&quot;&gt;&lt;/a&gt;SQL 笔记&lt;/h1&gt;&lt;h2 id=&quot;SQL-简介&quot;&gt;&lt;a href=&quot;#SQL-简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="SQL" scheme="https://ghostychen.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>图解http读书笔记3</title>
    <link href="https://ghostychen.github.io/2020/05/21/20200521-03/"/>
    <id>https://ghostychen.github.io/2020/05/21/20200521-03/</id>
    <published>2020-05-21T14:43:25.000Z</published>
    <updated>2020-05-21T14:49:10.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第八章：用户身份的认证"><a href="#第八章：用户身份的认证" class="headerlink" title="第八章：用户身份的认证"></a>第八章：用户身份的认证</h2><h3 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h3><ul><li>密码</li><li>动态令牌</li><li>数字证书</li><li>生物认证</li><li>IC卡等</li></ul><h3 id="BASIC认证"><a href="#BASIC认证" class="headerlink" title="BASIC认证"></a>BASIC认证</h3><h3 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h3><h3 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h3><h3 id="FormBase认证"><a href="#FormBase认证" class="headerlink" title="FormBase认证"></a>FormBase认证</h3><p>目前认证多半是基于表单认证，客户端会向服务器上的Web应用程序发送登录信息，按登陆信息的验证结果认证。</p><h4 id="Session（会话）管理及Cookie应用"><a href="#Session（会话）管理及Cookie应用" class="headerlink" title="Session（会话）管理及Cookie应用"></a>Session（会话）管理及Cookie应用</h4><p>使用Cookie管理Session，弥补HTTP协议中不存在的状态管理功能。</p><ol><li>客户端把用户ID和密码等登录信息放入报文实体部分，通常是用<strong>POST</strong>方法把请求发送给服务器，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。</li><li>服务器会发放识别用户的Session ID（想象成一种用来区分不同用户的等位符）。通过验证从客户端发送过来的登陆信息进行身份认证，然后把用户的认证状态与Session ID绑定记录着服务器端。</li><li>客户端接收到从服务器端发来的Session ID，作为Cookie保存在本地，下次发送请求时，浏览器会自动发送Cookie，服务器识别用户和认证状态。</li></ol><p>安全保存用户密码的方式是给密码加盐<code>salt</code>的方式增加额外信息，再使用散列函数计算散列值后保存。</p><p><code>salt</code>是服务器随机生成一个足够长的字符串，然后和密码字符串相连接生成散列值，当两个用户使用同一密码，但<code>salt</code>不同，对应的散列值也不同，减少了密码特征，增强安全性。</p><h2 id="第九章：基于HTTP的功能追加协议"><a href="#第九章：基于HTTP的功能追加协议" class="headerlink" title="第九章：基于HTTP的功能追加协议"></a>第九章：基于HTTP的功能追加协议</h2><h3 id="HTTP的瓶颈"><a href="#HTTP的瓶颈" class="headerlink" title="HTTP的瓶颈"></a>HTTP的瓶颈</h3><ul><li>一条连接上只可发送一个请求。</li><li>请求只能从客户端开始，客户端不可以接收除响应外的指令。</li><li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。</li><li>发送冗余的首部。每次互相发送相同的首部造成的浪费多。</li><li>可任意选择数据压缩格式。非强制压缩发送。</li></ul><h4 id="Ajax的解决方法（异步JavaScript与XML技术）"><a href="#Ajax的解决方法（异步JavaScript与XML技术）" class="headerlink" title="Ajax的解决方法（异步JavaScript与XML技术）"></a>Ajax的解决方法（异步JavaScript与XML技术）</h4><p>有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。</p><p>Ajax的核心技术是<code>XMLHttpRequest</code>的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。通过这种手段，就能从已加载完毕的Web页面上发起请求，只更新局部页面。</p><h4 id="Comet的解决方法"><a href="#Comet的解决方法" class="headerlink" title="Comet的解决方法"></a>Comet的解决方法</h4><p>通常，服务器接收请求会立即返回响应，但Comet会先将 响应置于挂起状态，当服务器有内容更新时，再返回响应。</p><h4 id="SPDY的设计和功能（已放弃–-gt-HTTP2）"><a href="#SPDY的设计和功能（已放弃–-gt-HTTP2）" class="headerlink" title="SPDY的设计和功能（已放弃–&gt;HTTP2）"></a>SPDY的设计和功能（已放弃–&gt;HTTP2）</h4><p>SPDY没有改写HTTP协议，而是在应用层和传输层之间通过新加会话层的形式运作，同时规定通信中使用SSL（表示层）。</p><p>SPDY控制数据的流动，还是采用HTTP建立通信连接。可照常使用HTTP的GET和POST方法，Cookie以及HTTP报文等。</p><ol><li>多路复用流</li><li>赋予请求优先级</li><li>压缩HTTP首部</li><li>推送功能</li><li>服务器提示功能</li></ol><h3 id="全双工通信的WebSocket"><a href="#全双工通信的WebSocket" class="headerlink" title="全双工通信的WebSocket"></a>全双工通信的WebSocket</h3><p><code>WebSocket</code>即Web浏览器和Web服务器之间全双工通信标准。</p><p>连接的发起方是客户端，而一旦确立了WS通信连接，无论是服务器还是客户端都可以直接向对方发送报文。</p><h4 id="WS协议主要特点："><a href="#WS协议主要特点：" class="headerlink" title="WS协议主要特点："></a>WS协议主要特点：</h4><ol><li>推送功能</li><li>减少通信量</li></ol><p>为了实现WS通信，客户端第一次请求的时候（一次握手），就采用upgrade头部信息告知服务端要升级协议。服务端返回状态码<code>101 Switching Protocols</code>的响应。确立握手后，通信就采用WebSocket独立的数据帧。</p><h3 id="Web服务器管理文件的WebDAV"><a href="#Web服务器管理文件的WebDAV" class="headerlink" title="Web服务器管理文件的WebDAV"></a>Web服务器管理文件的WebDAV</h3><p>WebDAV是一个可对Web服务器上的内容直接进行文件复制，编辑等操作的分布式文件系统。还具备文件创建者管理，文件加锁，以及对文件内容修改的版本控制功能。</p><h2 id="第十章：构建Web内容的技术"><a href="#第十章：构建Web内容的技术" class="headerlink" title="第十章：构建Web内容的技术"></a>第十章：构建Web内容的技术</h2><h3 id="发布更新信息的RSS-Atom"><a href="#发布更新信息的RSS-Atom" class="headerlink" title="发布更新信息的RSS/Atom"></a>发布更新信息的RSS/Atom</h3><p>都是发布新闻或博客日志等更新信息文档的格式的总称。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>是一种以JavaScript的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有false/null/true/对象/数组/数字/字符串，共7种类型。</p><h2 id="第十一章：Web攻击技术"><a href="#第十一章：Web攻击技术" class="headerlink" title="第十一章：Web攻击技术"></a>第十一章：Web攻击技术</h2><h3 id="针对Web应用的攻击模式"><a href="#针对Web应用的攻击模式" class="headerlink" title="针对Web应用的攻击模式"></a>针对Web应用的攻击模式</h3><ul><li><p>主动攻击</p><p>主动攻击是指攻击者通过直接访问Web应用，把攻击代码传入的模式。——SQL注入攻击和OS命令注入攻击。</p></li><li><p>被动攻击</p><p>利用圈套策略执行攻击代码，不直接对目标Web应用访问发起攻击。——跨站脚本攻击和跨站点请求伪造。</p></li></ul><h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><p><strong>跨站脚本攻击（XSS）</strong>是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。</p><ul><li>利用虚假输入表单骗取用户个人信息。</li><li>窃取用户Cookie值，帮助攻击者发送恶意请求。</li><li>显示伪造的文章或图片。</li></ul><p><strong>对用户Cookie的窃取攻击</strong>。</p><p><strong>SQL注入攻击</strong>是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。</p><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><p><strong>OS命令注入攻击</strong>是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要能在调用Shell函数的地方就存在被攻击的风险。</p><p><strong>HTTP首部注入攻击</strong>是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击，是被动攻击模式。</p><ul><li>设置任何Cookie信息</li><li>重定向至任意URL</li></ul><p><strong>邮件首部注入攻击</strong></p><p><strong>目录遍历攻击</strong></p><p><strong>远程文件包含漏洞</strong></p><h3 id="因设置或设计上的缺陷引发的安全漏洞"><a href="#因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="因设置或设计上的缺陷引发的安全漏洞"></a>因设置或设计上的缺陷引发的安全漏洞</h3><p><strong>强制浏览</strong></p><p><strong>不正确的错误消息处理</strong></p><p><strong>开放重定向</strong></p><h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="headerlink" title="因会话管理疏忽引发的安全漏洞"></a>因会话管理疏忽引发的安全漏洞</h3><p><strong>会话劫持</strong></p><p><strong>会话固定攻击</strong></p><p><strong>跨站点请求伪造</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第八章：用户身份的认证&quot;&gt;&lt;a href=&quot;#第八章：用户身份的认证&quot; class=&quot;headerlink&quot; title=&quot;第八章：用户身份的认证&quot;&gt;&lt;/a&gt;第八章：用户身份的认证&lt;/h2&gt;&lt;h3 id=&quot;用户认证&quot;&gt;&lt;a href=&quot;#用户认证&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="http读书笔记" scheme="https://ghostychen.github.io/categories/http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http" scheme="https://ghostychen.github.io/tags/http/"/>
    
      <category term="读书笔记" scheme="https://ghostychen.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解http读书笔记2</title>
    <link href="https://ghostychen.github.io/2020/05/21/20200521-02/"/>
    <id>https://ghostychen.github.io/2020/05/21/20200521-02/</id>
    <published>2020-05-21T14:42:58.000Z</published>
    <updated>2020-05-21T14:48:48.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章：返回结果的HTTP状态码"><a href="#第四章：返回结果的HTTP状态码" class="headerlink" title="第四章：返回结果的HTTP状态码"></a>第四章：返回结果的HTTP状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p><p>状态码由3位数字和原因短语组成。</p><h3 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h3><table><thead><tr><th></th><th>类别</th><th align="left">原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td align="left">接受的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td align="left">请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td align="left">需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td align="left">服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器端错误状态码</td><td align="left">服务器处理请求出错</td></tr></tbody></table><p>只要遵循状态码类别，服务器端自行创建状态码是可行的。</p><h3 id="14种代表性状态码"><a href="#14种代表性状态码" class="headerlink" title="14种代表性状态码"></a>14种代表性状态码</h3><ul><li><p>200 OK</p><p>表示从客户端发来的请求在服务器端被正常处理。</p></li><li><p>204 No Content</p><p>表示服务器接收的请求已成功处理，但返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体，浏览器的页面不发生更新。</p></li><li><p>206 Partial Content</p><p>客户端进行了范围请求，服务器成功执行了这部分的GET请求。</p><hr></li><li><p>301 Moved Permanently</p><p>永久性重定向，表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。</p></li><li><p>302 Found</p><p>临时性重定向，表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。</p></li><li><p>303 See Other</p><p>表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p></li><li><p>304 Not Modified</p><p>服务器资源未改变，可直接使用客户端未过期的缓存。</p></li><li><p>307 Temporary Redirect</p><p>临时重定向，不同于302，不会把POST变成GET。</p><hr></li><li><p>400 Bad Request</p><p>表示请求报文存在语法错误，当错误发送时，需修改请求的内容再次发送请求。</p></li><li><p>401 Unauthorized</p><p>表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过一次请求，则表示用户认证失败。</p></li><li><p>403 Forbidden</p><p>表明对请求资源的访问被服务器拒绝了，可在实体的主体部分对拒绝原因进行描述。</p></li><li><p>404 Not Found</p><p>表明服务器上无法找到请求的资源，或服务器拒绝请求切不想说明原因。</p><hr></li><li><p>500 Internal Server Error</p><p>表明服务器端在执行请求时发生错误，也有可能是Web应用存在的bug或某些临时的故障。</p></li><li><p>503 Service Unavailable</p><p>服务器暂时处于超负载或正在进行停机维护，无法处理请求。</p></li></ul><h2 id="第五章：与HTTP协作的Web服务器"><a href="#第五章：与HTTP协作的Web服务器" class="headerlink" title="第五章：与HTTP协作的Web服务器"></a>第五章：与HTTP协作的Web服务器</h2><h3 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h3><p>在相同IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p><h3 id="通信数据转发程序：代理，网关，隧道"><a href="#通信数据转发程序：代理，网关，隧道" class="headerlink" title="通信数据转发程序：代理，网关，隧道"></a>通信数据转发程序：代理，网关，隧道</h3><ul><li><p>代理</p><p>接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。转发时，需要附加Via首部字段以标记出经过的主机信息。</p><p>目的：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，获取访问日志。</p><ul><li><p>缓存代理</p><p>预先把资源的副本（缓存）保存在代理服务器上，当代理再次接收到相同资源的请求就可以直接使用代理服务器上的资源作为响应返回。</p></li><li><p>透明代理</p><p>不对报文做任何加工的代理类型，反之为非透明代理。</p></li></ul></li><li><p>网关</p><p>与代理相似，而网关能使通信线路上的服务器提供非HTTP协议服务。</p><p>比如：网关可连接数据库，使用SQL语句查询数据。</p></li><li><p>隧道</p><p>建立一条与其他服务器的通信线路，目的是确保客户端能与服务器进行安全的通信。隧道本身不会解析HTTP请求。通过隧道的传输，可以和远距离的服务器安全通信。</p></li></ul><h3 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h3><p>缓存是指代理服务器或者客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，节省通信流量和通信时间。</p><p>缓存的有效期限需要向源服务器确认资源的有效性，若缓存失效，缓存服务器会再次从源服务器上获取“新”资源。</p><h2 id="第六章：HTTP头部"><a href="#第六章：HTTP头部" class="headerlink" title="第六章：HTTP头部"></a>第六章：HTTP头部</h2><h3 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h3><p>报文首部内容为客户端和服务器分别处理请求和响应提供所需要的信息，大部分内容客户端用户无需查看。</p><p>报文主体为用户和资源的信息。</p><ul><li><p>HTTP请求报文</p><p>方法，URI，HTTP版本，HTTP首部字段等构成。</p></li><li><p>HTTP响应报文</p><p>HTTP版本，状态码（数字和原因短语），HTTP首部字段3部分构成。</p></li></ul><h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用的语言，认证信息等内容。</p><h4 id="首部字段结构"><a href="#首部字段结构" class="headerlink" title="首部字段结构"></a>首部字段结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首部字段名：字段值</span><br><span class="line">Content-Type:text&#x2F;html</span><br><span class="line">Keep-Alive:timeout&#x3D;15,max&#x3D;100</span><br></pre></td></tr></table></figure><h4 id="4种HTTP首部字段类型"><a href="#4种HTTP首部字段类型" class="headerlink" title="4种HTTP首部字段类型"></a>4种HTTP首部字段类型</h4><ul><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ul><p>RFC2616定义的46种外，还有Cookie，Set-Cookie和Content-Disposition等。</p><h4 id="定义成缓存代理和非缓存代理"><a href="#定义成缓存代理和非缓存代理" class="headerlink" title="定义成缓存代理和非缓存代理"></a>定义成缓存代理和非缓存代理</h4><ul><li>端到端首部（End-to-end Header）</li><li>逐跳首部（Hop-by-hop Header）</li></ul><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><p>ETag：能告知客户端实体标识，是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值。</p><ul><li>强ETag：无论实体发生多么细微的变化都会改变值。</li><li>弱ETag：只有资源发生了根本改变，产生差异时才会改变ETag值。</li></ul><p>Vary：对缓存进行控制，相当于一个供有效缓存所在地所使用的自检器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><p>当代理服务器接收到带有Vary首部字段指定获取资源的请求时，如果使用的<code>Accept-Language</code>字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回。</p><h3 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h3><p>Cookie的工作机制是用户识别及状态管理；</p><ul><li><p>Set-Cookie：响应首部字段，开始状态管理所使用的Cookie信息。</p><p>HttpOnly属性：使JavaScript脚本无法获得Cookie，主要目的是防止跨站脚本攻击（XSS）对Cookie的信息窃取。</p></li><li><p>Cookie：当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收多个Cookie时，同样可以以多个Cookie形式发送。</p></li></ul><h3 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h3><p>HTTP首部字段是可以自行扩展的。</p><ul><li><p>X-Frame-Options</p><p>主要目的是为了防止点击劫持攻击。</p></li><li><p>X-XSS-Protection</p><p>针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器XSS防护机制的开关。</p></li><li><p>DNT</p><p>Do Not Track，表示拒绝被精准广告追踪的一种方法。</p></li><li><p>P3P</p><p>在线隐私偏好平台技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p></li></ul><h2 id="第七章：确保Web安全的HTTPS"><a href="#第七章：确保Web安全的HTTPS" class="headerlink" title="第七章：确保Web安全的HTTPS"></a>第七章：确保Web安全的HTTPS</h2><h3 id="HTTP的缺点（内容保密性，身份验证，内容完整性）"><a href="#HTTP的缺点（内容保密性，身份验证，内容完整性）" class="headerlink" title="HTTP的缺点（内容保密性，身份验证，内容完整性）"></a>HTTP的缺点（内容保密性，身份验证，内容完整性）</h3><ul><li>通信使用明文（不加密），内容可能会被窃听。</li><li>不验证通信方身份，有可能遭遇伪装。</li><li>无法证明报文的完整性，有可能已遭篡改。</li></ul><hr><p>TCP/IP是各个环节都可能被窃听的网络，因此需要加密处理来防止被窃听。</p><ul><li>通信加密：通过SSL（Secure Socket Layer 安全套接层）或TLS（Transport Layer Security安全传输层协议）的组合使用，加密HTTP的通信内容。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。</li><li>内容加密：对HTTP报文主体进行加密，前提是要求客户端和服务器同时具备加密和解密机制。</li></ul><h4 id="不确认通信方，存在的安全隐患"><a href="#不确认通信方，存在的安全隐患" class="headerlink" title="不确认通信方，存在的安全隐患"></a>不确认通信方，存在的安全隐患</h4><ul><li>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。</li><li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。</li><li>无法确定正在通信的对方是否具有访问权限。</li><li>无法判定请求是来自哪里。</li><li>无意义的请求也会响应（DoS攻击，拒绝服务攻击）</li></ul><h4 id="无法证明报文完整性"><a href="#无法证明报文完整性" class="headerlink" title="无法证明报文完整性"></a>无法证明报文完整性</h4><p>没有任何办法确认，发出请求/响应和接收到的请求/响应是前后相同的。</p><p>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击。（比如写信）</p><h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护 = HTTPS"></a>HTTP+加密+认证+完整性保护 = HTTPS</h3><p>SSL是独立于HTTP的协议，不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。HTTPS就是身披SSL协议外壳的HTTP。</p><h4 id="公开密钥加密技术"><a href="#公开密钥加密技术" class="headerlink" title="公开密钥加密技术"></a>公开密钥加密技术</h4><p>加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。</p><p>使用两把密钥的公开密钥加密：发送密文一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后再使用自己的私有密钥进行解密。</p><p>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。使用公开密钥方式交换共享密钥，之后使用共享密钥加密方式进行通信。</p><p>问题：无法证明公开密钥本身就是货真价实的公开密钥——数字认证机构（CA）和相关机构颁发的公开密钥证书。</p><h4 id="HTTPS的安全通信机制"><a href="#HTTPS的安全通信机制" class="headerlink" title="HTTPS的安全通信机制"></a>HTTPS的安全通信机制</h4><ol><li>选择加密算法和相应组件</li><li>传输加密公钥</li><li>建立SSL通道</li><li>传输HTTP报文</li></ol><p>协商加密方式，服务器下发证书，客户端检验证书，交换通信密钥，HTTP业务通讯。</p><p>SSL导致处理速度变慢，分为通信慢和消耗大量CPU及内存资源导致的处理速度变慢-变慢2到100倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第四章：返回结果的HTTP状态码&quot;&gt;&lt;a href=&quot;#第四章：返回结果的HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;第四章：返回结果的HTTP状态码&quot;&gt;&lt;/a&gt;第四章：返回结果的HTTP状态码&lt;/h2&gt;&lt;p&gt;状态码的职责是当客户端向服务
      
    
    </summary>
    
    
      <category term="http读书笔记" scheme="https://ghostychen.github.io/categories/http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http" scheme="https://ghostychen.github.io/tags/http/"/>
    
      <category term="读书笔记" scheme="https://ghostychen.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解http读书笔记1</title>
    <link href="https://ghostychen.github.io/2020/05/20/20200520-01-1/"/>
    <id>https://ghostychen.github.io/2020/05/20/20200520-01-1/</id>
    <published>2020-05-20T14:57:20.000Z</published>
    <updated>2020-05-20T15:02:13.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：了解Web及网络基础"><a href="#第一章：了解Web及网络基础" class="headerlink" title="第一章：了解Web及网络基础"></a>第一章：了解Web及网络基础</h2><p>HTTP<code>（HyperText Transfer Protocol）</code>超文本传输协议。</p><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>协议：各类电子设备和软件系统通过有线网络设备或无线网络设备连接，必须在统一的规则（工业标准）下才可以协调工作。</p><p>传输控制协议：<code>transmission control protocol</code>  网络连接协议：<code>internet protocol</code></p><p>TCP/IP协议族按层次分为以下四层：应用层，传输层，网络层和数据链路层。</p><ul><li><p>应用层：决定了向用户提供应用服务时通信的活动</p><p>FTP协议：文件传输协议</p><p>HTTP协议</p><p>DNS：域名系统</p></li><li><p>传输层：对上层应用层，提供处于网络连接中两台计算机之间的数据传输</p><p>TCP：传输控制协议</p><p>UDP：用户数据报协议</p></li><li><p>网络层：处理网络上流动的数据包，规定了传输路线</p></li><li><p>链路层：用来处理连接网络的硬件部分</p></li></ul><h3 id="IP，TCP和DNS"><a href="#IP，TCP和DNS" class="headerlink" title="IP，TCP和DNS"></a>IP，TCP和DNS</h3><ul><li><p>IP位于网络层，作用是把各种数据包传送给对方，需要满足IP地址（可能多个）和MAC地址（地理位置唯一性）才能确保传送到。IP和MAC是多对一的关系</p></li><li><p>TCP位于传输层，提供可靠的字节流服务（把大块数据分割成以报文段为单位的数据包进行管理和准确可靠的传给对方）</p><p>TCP协议的三次握手策略：发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若某个阶段中断，会再次以相同的顺序发送相同的数据包。</p></li><li><p>DNS<code>Domain Name System</code>服务是应用层协议，提供域名到IP地址之间的解析服务。</p><p>ARP<code>Address resolution Protocol</code>解析地址协议，根据通信方的IP地址反查对应的MAC地址。</p></li></ul><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI用字符串标识某一互联网资源，而URL表示资源的地址（互联网上所处的位置）。URL是URI的子集。</p><h2 id="第二章：简单的HTTP协议"><a href="#第二章：简单的HTTP协议" class="headerlink" title="第二章：简单的HTTP协议"></a>第二章：简单的HTTP协议</h2><p>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p><p>HTTP协议规定：请求从客户端发出，最后服务器端响应请求并返回。</p><h3 id="客户端和服务器端通信"><a href="#客户端和服务器端通信" class="headerlink" title="客户端和服务器端通信"></a>客户端和服务器端通信</h3><ul><li><p>客户端发送请求报文：</p><p>请求报文由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成。</p></li><li><p>服务器发送响应报文：</p><p>响应报文基本上由协议版本，状态码（表示请求成功或失败的数字代码），用以解释状态码的原因短语，可选的响应首部字段以及实体主体构成。</p></li></ul><h3 id="HTTP是无状态stateless协议"><a href="#HTTP是无状态stateless协议" class="headerlink" title="HTTP是无状态stateless协议"></a>HTTP是无状态<code>stateless</code>协议</h3><p>HTTP协议自身不对请求和响应之间的通信状态进行保存。所以需要通过设置<code>cookie</code>来验证状态，比如<code>session</code>。为了更快的处理大量事务，确保协议的可伸缩性。如果对服务器本身发起请求，可以用一个<code>*</code>来代替请求URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><ul><li><p>GET：获取资源</p><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。</p></li><li><p>POST：传输实体主体</p></li><li><p>PUT：传输文件</p></li><li><p>HEAD：获得报文首部</p><p>HEAD与GET方法一样，只是不返回报文主体部分。</p></li><li><p>DELETE：删除文件</p></li><li><p>OPTIONS：询问支持的方法</p><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p></li><li><p>TRACE：追踪路径</p></li><li><p>CONNECT：要求用隧道协议连接代理</p></li></ul><h3 id="持节连接节省通信量"><a href="#持节连接节省通信量" class="headerlink" title="持节连接节省通信量"></a>持节连接节省通信量</h3><p>持节连接特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p><p>管线化：不需等待，同时发送多个请求。</p><h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p><code>Cookie会根据从服务器端发送的响应报文内的一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</code></p><p>Cookie是保存在客户端的，Cookie的内容可以是任意文本。但实际使用中并不直接在Cookie中包含信息，只是包含一个ID，配合服务端的session，以该ID为key获取用户信息。</p><h2 id="第三章：HTTP报文内的HTTP信息"><a href="#第三章：HTTP报文内的HTTP信息" class="headerlink" title="第三章：HTTP报文内的HTTP信息"></a>第三章：HTTP报文内的HTTP信息</h2><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文大致分为报文首部和报文主体两块。两者由空行（CR+LF）来划分，通常不需要有报文主体。</p><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><ul><li><p>请求报文</p><p>请求行（请求方法，请求URI，HTTP版本）</p><p>请求首部字段</p><p>通用首部字段</p><p>实体首部字段</p><p>其他</p></li><li><p>响应报文</p><p>状态行（状态码，原因短语和HTTP版本）</p><p>响应首部字段</p><p>通用首部字段</p><p>实体首部字段</p><p>其他</p></li></ul><h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><ul><li>压缩传输的内容编码</li><li>分割发送的分块传输编码</li></ul><h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议采纳多部分对象集合，发送的一份报文主体内可包含多类型实体。通常在图片或文本文件等上传时使用。需要在首部字段加Content-type。</p><h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>情景：恢复从之前下载中断处恢复下载。</p><p>指定下载的实体范围，指定范围发送的请求叫做范围请求。首部字段Range来指定资源的byte范围。如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p><h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。</p><p>内容协商技术有三种类型</p><ul><li>服务器驱动协商</li><li>客户端驱动协商</li><li>透明协商</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章：了解Web及网络基础&quot;&gt;&lt;a href=&quot;#第一章：了解Web及网络基础&quot; class=&quot;headerlink&quot; title=&quot;第一章：了解Web及网络基础&quot;&gt;&lt;/a&gt;第一章：了解Web及网络基础&lt;/h2&gt;&lt;p&gt;HTTP&lt;code&gt;（HyperText T
      
    
    </summary>
    
    
      <category term="http读书笔记" scheme="https://ghostychen.github.io/categories/http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="http" scheme="https://ghostychen.github.io/tags/http/"/>
    
      <category term="读书笔记" scheme="https://ghostychen.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>阮一峰js教程读书笔记2</title>
    <link href="https://ghostychen.github.io/2020/05/20/20200520-02/"/>
    <id>https://ghostychen.github.io/2020/05/20/20200520-02/</id>
    <published>2020-05-19T17:13:46.000Z</published>
    <updated>2020-05-20T15:02:03.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>定义：对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</li><li>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</li><li>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，可以像函数一样调用。</li><li>如果属性的值还是一个对象，就形成了链式引用。</li></ul><h3 id="对象中属性的操作"><a href="#对象中属性的操作" class="headerlink" title="对象中属性的操作"></a>对象中属性的操作</h3><ul><li><p>读取属性</p><p>一种是使用点运算符，还有一种是使用方括号运算符。</p><p><strong>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。同时，方括号运算符内部还可以使用表达式。数字键可以不加引号，因为会自动转成字符串</strong></p><p>数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p></li><li><p>属性赋值</p></li><li><p>查看所有属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  key1: 1,</span><br><span class="line">  key2: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj);</span><br><span class="line">&#x2F;&#x2F; [&#39;key1&#39;, &#39;key2&#39;]</span><br></pre></td></tr></table></figure></li><li><p>delete命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; p: 1 &#125;;</span><br><span class="line">Object.keys(obj) &#x2F;&#x2F; [&quot;p&quot;]</span><br><span class="line"></span><br><span class="line">delete obj.p &#x2F;&#x2F; true</span><br><span class="line">obj.p &#x2F;&#x2F; undefined</span><br><span class="line">Object.keys(obj) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure><p>删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p><p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p><p><code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性。</p></li><li><p>in 运算符</p><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。</p></li><li><p>for…in循环</p><p><code>for...in</code>循环用来遍历一个对象的全部属性。</p><p>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</p><p>它不仅遍历对象自身的属性，还遍历继承的属性。</p></li></ul><h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">with (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 操作同一个对象的多个属性时，提供一些书写的方便</span><br><span class="line">&#x2F;&#x2F; 例一</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  p1: 1,</span><br><span class="line">  p2: 2,</span><br><span class="line">&#125;;</span><br><span class="line">with (obj) &#123;</span><br><span class="line">  p1 &#x3D; 4;</span><br><span class="line">  p2 &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">obj.p1 &#x3D; 4;</span><br><span class="line">obj.p2 &#x3D; 5;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例二</span><br><span class="line">with (document.links[0])&#123;</span><br><span class="line">  console.log(href);</span><br><span class="line">  console.log(title);</span><br><span class="line">  console.log(style);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">console.log(document.links[0].href);</span><br><span class="line">console.log(document.links[0].title);</span><br><span class="line">console.log(document.links[0].style);</span><br></pre></td></tr></table></figure><p>如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量，<strong>会污染全局作用域。</strong>所以不建议使用with语句，可以用一个临时变量代替with。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="1-加法运算符"><a href="#1-加法运算符" class="headerlink" title="1.加法运算符"></a>1.加法运算符</h3><ul><li>加法运算符存在重载，会执行相加或连接，由运算时决定。</li><li>其他运算符不会发送重载，所有运算子都转化为数值，再进行相应的数学运算。</li></ul><h3 id="2-算数运算符"><a href="#2-算数运算符" class="headerlink" title="2.算数运算符"></a>2.算数运算符</h3><ul><li>余数运算符（运算结果的正负号由第一个运算子的正负号决定）</li><li>自增自减运算符</li><li>数值运算符，负数值运算符   <em>数值运算符的作用在于可以将任何值转为数值（与<code>Number</code>函数的作用相同）</em></li><li>指数运算符（**）</li></ul><h3 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3.赋值运算符"></a>3.赋值运算符</h3><h3 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4.比较运算符"></a>4.比较运算符</h3><p>相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p><p>特殊情况，即任何值（包括<code>NaN</code>本身）与<code>NaN</code>比较，返回的都是<code>false</code>。</p><p>如果运算子是对象，会转为原始类型的值，再进行比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; [2];</span><br><span class="line">x &gt; &#39;11&#39; &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 等同于 [2].valueOf().toString() &gt; &#39;11&#39;</span><br><span class="line">&#x2F;&#x2F; 即 &#39;2&#39; &gt; &#39;11&#39;</span><br><span class="line"></span><br><span class="line">[2] &gt; [11] &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 等同于 [2].valueOf().toString() &gt; [11].valueOf().toString()</span><br><span class="line">&#x2F;&#x2F; 即 &#39;2&#39; &gt; &#39;11&#39;</span><br></pre></td></tr></table></figure><ul><li><h4 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h4><p>正<code>0</code>等于负<code>0</code>。</p><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</p></li><li><h4 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h4><p>原始类型的数据会转换成数值类型再进行比较。</p><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</p><p><code>undefined</code>和<code>null</code>与其他类型的值比较时，结果都为<code>false</code>，它们互相比较时结果为<code>true</code>。</p></li></ul><h3 id="5-布尔运算符"><a href="#5-布尔运算符" class="headerlink" title="5.布尔运算符"></a>5.布尔运算符</h3><ul><li><p>取反运算符：<code>!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!undefined &#x2F;&#x2F; true</span><br><span class="line">!null &#x2F;&#x2F; true</span><br><span class="line">!0 &#x2F;&#x2F; true</span><br><span class="line">!NaN &#x2F;&#x2F; true</span><br><span class="line">!&quot;&quot; &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F;其他值都为false</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>且运算符：<code>&amp;&amp;</code></p><p>如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p></li><li><p>或运算符：<code>||</code></p><p>如果第一个运算子的布尔值为<code>true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code>false</code>，则返回第二个运算子的值。</p></li><li><p>三元运算符：<code>?:</code></p></li></ul><h3 id="6-位运算符"><a href="#6-位运算符" class="headerlink" title="6.位运算符"></a>6.位运算符</h3><p>位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。用于取整。</p><p><strong>一个数与自身的取反值相加，等于-1。</strong></p><p>使用二进制否运算取整，是所有取整方法中最快的一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~~2.9 &#x2F;&#x2F; 2</span><br><span class="line">~~47.11 &#x2F;&#x2F; 47</span><br><span class="line">~~1.9999 &#x2F;&#x2F; 1</span><br><span class="line">~~3 &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>“异或运算”有一个特殊运用，连续对两个数<code>a</code>和<code>b</code>进行三次异或运算，<code>a^=b; b^=a; a^=b;</code>，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。这是互换两个变量的值的最快方法。                 异或运算也可以用来取整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; RGB to HEX</span><br><span class="line">&#x2F;&#x2F; (1 &lt;&lt; 24)的作用为保证结果是6位数</span><br><span class="line">var rgb2hex &#x3D; function(r, g, b) &#123;</span><br><span class="line">  return &#39;#&#39; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b)</span><br><span class="line">    .toString(16) &#x2F;&#x2F; 先转成十六进制，然后返回字符串</span><br><span class="line">    .substr(1);   &#x2F;&#x2F; 去除字符串的最高位，返回后面六个字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带符号位的右移运算符（<code>&gt;&gt;&gt;</code>）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补<code>0</code>。所以，该运算总是得到正值。</p><h3 id="7-其他运算符"><a href="#7-其他运算符" class="headerlink" title="7.其他运算符"></a>7.其他运算符</h3><ul><li><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>。</p><p>主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。</p></li><li><p>逗号运算符用于对两个表达式求值，并返回<strong>后</strong>一个表达式的值。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;定义：对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。&lt;/li&gt;
&lt;li&gt;如果键名不符合标识名的条
      
    
    </summary>
    
    
      <category term="Js读书笔记" scheme="https://ghostychen.github.io/categories/Js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="https://ghostychen.github.io/tags/Javascript/"/>
    
      <category term="读书笔记" scheme="https://ghostychen.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>阮一峰js教程读书笔记1</title>
    <link href="https://ghostychen.github.io/2020/05/20/20200520-01/"/>
    <id>https://ghostychen.github.io/2020/05/20/20200520-01/</id>
    <published>2020-05-19T17:13:15.000Z</published>
    <updated>2020-05-19T17:17:04.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-与-ECMAScript的关系"><a href="#JavaScript-与-ECMAScript的关系" class="headerlink" title="JavaScript 与 ECMAScript的关系"></a>JavaScript 与 ECMAScript的关系</h2><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。</p><h2 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h2><p>1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求，为后来大行其道的 Ajax 应用创造了条件。</p><p>2001年，Douglas Crockford 提出了 JSON 格式，用于取代 XML 格式，进行服务器和网页之间的数据交换。JavaScript 可以原生支持这种格式，不需要额外部署代码。</p><h2 id="语法注意点"><a href="#语法注意点" class="headerlink" title="语法注意点"></a>语法注意点</h2><ul><li><p>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>不合法的标识符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>a  <span class="comment">// 第一个字符不能是数字</span></span><br><span class="line"><span class="number">23</span>  <span class="comment">// 同上</span></span><br><span class="line">***  <span class="comment">// 标识符不能包含星号</span></span><br><span class="line">a+b  <span class="comment">// 标识符不能包含加号</span></span><br><span class="line">-d  <span class="comment">// 标识符不能包含减号或连词线</span></span><br></pre></td></tr></table></figure></li><li><p><code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 发生类型转换'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 没有发生类型转换'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></table></figure></li><li><p>不管条件是否为真，<code>do...while</code>循环至少运行一次，这是这种结构最大的特点</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p><strong>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）</strong></p></li><li><p><strong>字符串（string）：文本（比如<code>Hello World</code>）。</strong></p></li><li><p><strong>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）</strong></p></li><li><p><strong><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</strong></p></li><li><p><strong><code>null</code>：表示空值，即此处的值为空。</strong></p></li><li><p><strong>对象（object）：各种值组成的集合。</strong></p><ul><li>狭义的对象（object）</li><li>数组（array）</li><li>函数（function）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeof 检测值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// "boolean"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line">v</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"><span class="keyword">typeof</span> v</span><br><span class="line"><span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。</p></li><li><p><code>undefined</code>表示“未定义”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>布尔值转换规则</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li></ul></li></ul><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><ul><li><p>所有数字都是64位浮点数形式存储</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>数值精度(浮点数的64个二进制位)</p><ul><li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li><li>第2位到第12位（共11位）：指数部分</li><li>第13位到第64位（共52位）：小数部分（即有效数字）</li></ul></li></ul><p>  简单的法则就是，JavaScript 对15位的十进制数都可以精确处理<br>  NaN不是独立的数据类型，数据类型依然是Number。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F;false </span><br><span class="line">[NaN].indexof(NaN) &#x2F;&#x2F;-1</span><br><span class="line">Boolean(NaN) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">NaN + 32 &#x2F;&#x2F; NaN</span><br><span class="line">NaN - 32 &#x2F;&#x2F; NaN</span><br><span class="line">NaN * 32 &#x2F;&#x2F; NaN</span><br><span class="line">NaN &#x2F; 32 &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><p>  <code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到<code>Infinity</code>。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2,1024) &#x2F;&#x2F;Infinity</span><br><span class="line"></span><br><span class="line">0 &#x2F; 0 &#x2F;&#x2F;NaN</span><br><span class="line">1 &#x2F; 0 &#x2F;&#x2F;Infinity</span><br><span class="line"></span><br><span class="line">Infinity &#x3D;&#x3D;&#x3D; -Infinity &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">1 &#x2F; -0 &#x2F;&#x2F;-Infinity</span><br><span class="line">-1 &#x2F; -0 &#x2F;&#x2F;Infinity</span><br><span class="line"></span><br><span class="line">Infinity &gt; 1000 &#x2F;&#x2F;true</span><br><span class="line">-Infinity &lt; -1000 &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">Infinity &gt; NaN &#x2F;&#x2F; false</span><br><span class="line">-Infinity &gt; NaN &#x2F;&#x2F; false</span><br><span class="line">Infinity &lt; NaN &#x2F;&#x2F; false</span><br><span class="line">-Infinity &lt; NaN &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Infinity的四则运算，符合无穷的数学计算规则。</span><br><span class="line">5 * Infinity &#x2F;&#x2F; Infinity</span><br><span class="line">5 - Infinity &#x2F;&#x2F; -Infinity</span><br><span class="line">Infinity &#x2F; 5 &#x2F;&#x2F; Infinity</span><br><span class="line">5 &#x2F; Infinity &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">0 * Infinity &#x2F;&#x2F; NaN</span><br><span class="line">0 &#x2F; Infinity &#x2F;&#x2F; 0</span><br><span class="line">Infinity &#x2F; 0 &#x2F;&#x2F; Infinity</span><br><span class="line"></span><br><span class="line">Infinity + Infinity &#x2F;&#x2F; Infinity</span><br><span class="line">Infinity * Infinity &#x2F;&#x2F; Infinity</span><br><span class="line"></span><br><span class="line">Infinity - Infinity &#x2F;&#x2F; NaN</span><br><span class="line">Infinity &#x2F; Infinity &#x2F;&#x2F; NaN</span><br><span class="line">Infinity与null计算时，null会转成0，等同于与0的计算。</span><br><span class="line">null * Infinity &#x2F;&#x2F; NaN</span><br><span class="line">null &#x2F; Infinity &#x2F;&#x2F; 0</span><br><span class="line">Infinity &#x2F; null &#x2F;&#x2F; Infinity</span><br><span class="line"></span><br><span class="line">Infinity与undefined计算，返回的都是NaN。</span><br><span class="line">undefined + Infinity &#x2F;&#x2F; NaN</span><br><span class="line">undefined - Infinity &#x2F;&#x2F; NaN</span><br><span class="line">undefined * Infinity &#x2F;&#x2F; NaN</span><br><span class="line">undefined &#x2F; Infinity &#x2F;&#x2F; NaN</span><br><span class="line">Infinity &#x2F; undefined &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure><h2 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h2><ul><li><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseInt(1000000000000000000000.5) &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">parseInt(&#39;1e+21&#39;) &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">parseInt(0.0000008) &#x2F;&#x2F; 8</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">parseInt(&#39;8e-7&#39;) &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure></li><li><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p>字符串符合科学计数法，则会进行相应的转换。</p><p><code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p></li><li><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p><code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。</p><p>对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>,原因是这些数组能被<code>Number</code>函数转成数值。</p></li><li><h3 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h3><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-与-ECMAScript的关系&quot;&gt;&lt;a href=&quot;#JavaScript-与-ECMAScript的关系&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 与 ECMAScript的关系&quot;&gt;&lt;/a&gt;JavaScri
      
    
    </summary>
    
    
      <category term="Js读书笔记" scheme="https://ghostychen.github.io/categories/Js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="https://ghostychen.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令速查表</title>
    <link href="https://ghostychen.github.io/2020/05/19/art2020051902/"/>
    <id>https://ghostychen.github.io/2020/05/19/art2020051902/</id>
    <published>2020-05-19T12:38:14.000Z</published>
    <updated>2020-05-19T12:39:37.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git常用命令速查表"><a href="#Git常用命令速查表" class="headerlink" title="Git常用命令速查表"></a>Git常用命令速查表</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt;        #克隆远程版本库</span><br><span class="line">$ git init               #初始化本地版本库</span><br></pre></td></tr></table></figure><h2 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status              #查看状态</span><br><span class="line">$ git diff                #查看变更内容</span><br><span class="line">$ git add .               #跟踪所有改动过的文件</span><br><span class="line">$ git add &lt;file&gt;          #跟踪指定的文件</span><br><span class="line">$ git mv &lt;old&gt; &lt;new&gt;      #文件改名</span><br><span class="line">$ git rm &lt;file&gt;           #删除文件</span><br><span class="line">$ git rm --cached &lt;file&gt;              #停止跟踪文件但不删除</span><br><span class="line">$ git commit -m &quot;commit message&quot;      #提交所有更新过的文件</span><br><span class="line">$ git commit --amend                  #修改最后一次提交</span><br></pre></td></tr></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log               #查看提交历史         </span><br><span class="line">$ git log -p &lt;file&gt;     #查看指定文件的提交历史</span><br><span class="line">$ git blame &lt;file&gt;      #以列表方式查看指定文件的提交历史</span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --head HEAD         #撤销工作目录中所有未提交文件的修改内容</span><br><span class="line">$ git checkout HEAD &lt;file&gt;      #撤销指定的未提交文件的修改内容</span><br><span class="line">$ git revert &lt;commit&gt;           #撤销指定的提交</span><br></pre></td></tr></table></figure><h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch                     #显示所有的本地分支</span><br><span class="line">$ git checkout &lt;branch&#x2F;tag&gt;      #切换到指定分支或标签</span><br><span class="line">$ git branch &lt;new-branch&gt;        #创建新分支</span><br><span class="line">$ git branch -d &lt;branch&gt;         #删除本地分支</span><br><span class="line">$ git tag                        #列出所有本地标签</span><br><span class="line">$ git tag &lt;tagname&gt;              #基于最新提交创建标签</span><br><span class="line">$ git tag -d &lt;tagname&gt;           #删除标签</span><br></pre></td></tr></table></figure><h2 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branch&gt;         #合并指定分支到当前分支</span><br><span class="line">$ git rebase &lt;branch&gt;        #衍合指定分支到当前分支</span><br></pre></td></tr></table></figure><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v                             #查看远程版本库信息</span><br><span class="line">$ git remote show &lt;remote&gt;                  #查看指定远程版本库信息</span><br><span class="line">$ git remote add &lt;remote&gt; &lt;url&gt;             #添加远程版本库</span><br><span class="line">$ git fetch &lt;remote&gt;                        #从远程版本库获取代码</span><br><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;                #下载代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; &lt;branch&gt;                #上传代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; :&lt;branch&#x2F;tag-name&gt;      #删除远程分支或标签</span><br><span class="line">$ git push --tags                           #上传所有标签</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git常用命令速查表&quot;&gt;&lt;a href=&quot;#Git常用命令速查表&quot; class=&quot;headerlink&quot; title=&quot;Git常用命令速查表&quot;&gt;&lt;/a&gt;Git常用命令速查表&lt;/h1&gt;&lt;h2 id=&quot;创建版本库&quot;&gt;&lt;a href=&quot;#创建版本库&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="前端学习" scheme="https://ghostychen.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="https://ghostychen.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域解决方案</title>
    <link href="https://ghostychen.github.io/2020/05/19/art20200519/"/>
    <id>https://ghostychen.github.io/2020/05/19/art20200519/</id>
    <published>2020-05-19T12:32:16.000Z</published>
    <updated>2020-05-19T12:36:36.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端跨域解决方案"><a href="#前端跨域解决方案" class="headerlink" title="前端跨域解决方案"></a>前端跨域解决方案</h1><ol><li><h2 id="什么是前端跨域"><a href="#什么是前端跨域" class="headerlink" title="什么是前端跨域"></a>什么是前端跨域</h2><ul><li><p>跨域是浏览器为了安全做出的限制策略</p></li><li><p>浏览器请求必须遵守同源策略：同域名，同端口，同协议</p></li></ul></li><li><h2 id="怎么解决前端跨域"><a href="#怎么解决前端跨域" class="headerlink" title="怎么解决前端跨域"></a>怎么解决前端跨域</h2><ul><li><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>CORS跨域 - 服务端设置，前端直接调用</p><p>说明：后台允许前端某个站点进行访问</p><p>网站Easy Mock</p></li><li><h3 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h3><p>JSONP跨域 - 前端适配，后台配合</p><p>说明：前后台同时改造</p><p>注意：JSONP请求不是真正的请求，在XHR中没有，只是一段JS脚本</p><p>JSONP语法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let url &#x3D; &quot;https:&#x2F;&#x2F;www.imooc.com&#x2F;common&#x2F;adver-getadver&quot;</span><br><span class="line">    jsonp(url,&#123;&#125;，(err,res)&#x3D;&gt;&#123;</span><br><span class="line">      let result &#x3D; res;</span><br><span class="line">      this.data &#x3D; result;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><h3 id="代理跨域"><a href="#代理跨域" class="headerlink" title="代理跨域"></a>代理跨域</h3><p>接口代理 - 通过修改nginx服务器配置来实现</p><p>说明：前端修改，后台不动</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端跨域解决方案&quot;&gt;&lt;a href=&quot;#前端跨域解决方案&quot; class=&quot;headerlink&quot; title=&quot;前端跨域解决方案&quot;&gt;&lt;/a&gt;前端跨域解决方案&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;什么是前端跨域&quot;&gt;&lt;a href=&quot;#什么是前端跨域&quot; clas
      
    
    </summary>
    
    
      <category term="前端学习" scheme="https://ghostychen.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="跨域" scheme="https://ghostychen.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ghostychen.github.io/2020/05/12/hello-world/"/>
    <id>https://ghostychen.github.io/2020/05/12/hello-world/</id>
    <published>2020-05-12T00:26:36.605Z</published>
    <updated>2020-05-12T00:26:36.605Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue项目文件目录结构</title>
    <link href="https://ghostychen.github.io/2020/05/11/article/"/>
    <id>https://ghostychen.github.io/2020/05/11/article/</id>
    <published>2020-05-11T02:37:00.000Z</published>
    <updated>2020-05-12T00:26:36.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node环境安装"><a href="#Node环境安装" class="headerlink" title="Node环境安装"></a>Node环境安装</h2><h3 id="window-mac安装"><a href="#window-mac安装" class="headerlink" title="window/mac安装"></a>window/mac安装</h3><ul><li><a href="http://nodejs.cn/download" target="_blank" rel="noopener">http://nodejs.cn/download</a></li></ul><h2 id="Git安装和配置"><a href="#Git安装和配置" class="headerlink" title="Git安装和配置"></a>Git安装和配置</h2><ul><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>官网：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li></ul></li><li><h3 id="环境变量配置、开发工具配置"><a href="#环境变量配置、开发工具配置" class="headerlink" title="环境变量配置、开发工具配置"></a>环境变量配置、开发工具配置</h3><ul><li><p>查看设置本地环境变量</p><p>属性 –&gt; 高级 –&gt; 环境变量</p></li><li><p>配置VsCode的Git地址</p></li></ul></li><li><h3 id="存储密码-SSH添加公钥"><a href="#存储密码-SSH添加公钥" class="headerlink" title="存储密码 - SSH添加公钥"></a>存储密码 - SSH添加公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config --global user.name &#39;yourname&#39;</span><br><span class="line">git config --global user.email &#39;youremail@example.com&#39;</span><br><span class="line"></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置SSH密钥</span><br><span class="line">ssh-keygen -t rsa -C &#39;youremail@example.com&#39;</span><br></pre></td></tr></table></figure></li><li><h3 id="团队使用Git命令开发项目"><a href="#团队使用Git命令开发项目" class="headerlink" title="团队使用Git命令开发项目"></a>团队使用Git命令开发项目</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Node环境安装&quot;&gt;&lt;a href=&quot;#Node环境安装&quot; class=&quot;headerlink&quot; title=&quot;Node环境安装&quot;&gt;&lt;/a&gt;Node环境安装&lt;/h2&gt;&lt;h3 id=&quot;window-mac安装&quot;&gt;&lt;a href=&quot;#window-mac安装&quot; cla
      
    
    </summary>
    
    
      <category term="Vue全家桶高仿小米商城" scheme="https://ghostychen.github.io/categories/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%AB%98%E4%BB%BF%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E/"/>
    
    
      <category term="Vue" scheme="https://ghostychen.github.io/tags/Vue/"/>
    
      <category term="Git" scheme="https://ghostychen.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
